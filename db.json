{"Asset":[{"_id":"themes/cover/source/background.jpg","path":"background.jpg","modified":true},{"_id":"themes/cover/source/favicon.ico","path":"favicon.ico","modified":true},{"_id":"themes/cover/source/header.jpg","path":"header.jpg","modified":true},{"_id":"themes/cover/source/logo.png","path":"logo.png","modified":true},{"_id":"themes/cover/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":true},{"_id":"themes/cover/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":true},{"_id":"themes/cover/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":true},{"_id":"themes/cover/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":true},{"_id":"themes/cover/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":true},{"_id":"themes/cover/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":true},{"_id":"themes/cover/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":true},{"_id":"themes/cover/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":true},{"_id":"themes/cover/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":true},{"_id":"themes/cover/source/js/cover.js","path":"js/cover.js","modified":true},{"_id":"themes/cover/source/js/gallery.js","path":"js/gallery.js","modified":true},{"_id":"themes/cover/source/js/jquery.anystretch.min.js","path":"js/jquery.anystretch.min.js","modified":true},{"_id":"themes/cover/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":true},{"_id":"themes/cover/source/css/style.styl","path":"css/style.styl","modified":true}],"Cache":[{"_id":"scaffolds/draft.md","mtime":1414226564000},{"_id":"scaffolds/page.md","mtime":1414226564000},{"_id":"scaffolds/photo.md","mtime":1414226564000},{"_id":"scaffolds/post.md","mtime":1414226564000},{"_id":"source/_posts/about-functions-to-production.md","mtime":1415354755000},{"_id":"source/_posts/asking-the-right-questions.md","mtime":1416149486000},{"_id":"source/_posts/baby-come.md","mtime":1420817625000},{"_id":"source/_posts/before-baby-born.md","mtime":1420817163000},{"_id":"source/_posts/civiliztion-and-enlightenments.md","mtime":1420816868000},{"_id":"source/_posts/game-published.md","mtime":1419172736000},{"_id":"source/_posts/golang-at-google.md","mtime":1420816384000},{"_id":"source/_posts/idealist.md","mtime":1417968777000},{"_id":"source/_posts/just-do-it-better.md","mtime":1420816058000},{"_id":"source/_posts/new-start.md","mtime":1420817762000},{"_id":"source/_posts/new-year-firt-worlds.md","mtime":1420819252000},{"_id":"source/_posts/the-book-of-mozilla.md","mtime":1418550332000},{"_id":"source/_posts/the-text-encoding.md","mtime":1420815503000},{"_id":"source/_posts/the-tips-of-sublime.md","mtime":1420815755000},{"_id":"source/_posts/the-words-of-linus.md","mtime":1420817988000},{"_id":"source/_posts/the-world-internet-conference.md","mtime":1416758676000},{"_id":"source/books/index.md","mtime":1414233322000},{"_id":"source/books/test.md","mtime":1414243493000},{"_id":"source/friends/index.md","mtime":1414233463000},{"_id":"themes/cover/LICENSE","mtime":1414221112000},{"_id":"themes/cover/README.md","mtime":1414221112000},{"_id":"themes/cover/_config.yml","mtime":1414509089000},{"_id":"themes/cover/package.json","mtime":1414241817000},{"_id":"themes/cover/_widget/category.ejs","mtime":1414221112000},{"_id":"themes/cover/_widget/recent_posts.ejs","mtime":1414221112000},{"_id":"themes/cover/_widget/search.ejs","mtime":1414221112000},{"_id":"themes/cover/_widget/tag.ejs","mtime":1414221112000},{"_id":"themes/cover/_widget/tagcloud.ejs","mtime":1414221112000},{"_id":"themes/cover/languages/de.yml","mtime":1414221112000},{"_id":"themes/cover/languages/default.yml","mtime":1414221112000},{"_id":"themes/cover/languages/es.yml","mtime":1414221112000},{"_id":"themes/cover/languages/zh-CN.yml","mtime":1414221112000},{"_id":"themes/cover/languages/zh-TW.yml","mtime":1414221112000},{"_id":"themes/cover/_partial/about.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/after_footer.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/archive.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/article.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/comment.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/duoshuo_comment.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/footer.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/google_analytics.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/head.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/header.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/pagination.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/sidebar.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/social.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/post/category.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/post/gallery.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/post/share.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/post/tag.ejs","mtime":1414221112000},{"_id":"themes/cover/_partial/post/title.ejs","mtime":1414509553000},{"_id":"themes/cover/layout/about.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/archive.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/article.ejs","mtime":1414247088000},{"_id":"themes/cover/layout/blog.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/category.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/index.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/index.ejs.back","mtime":1414221112000},{"_id":"themes/cover/layout/layout.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/layout.ejs.back","mtime":1414221112000},{"_id":"themes/cover/layout/page.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/post.ejs","mtime":1414244597000},{"_id":"themes/cover/layout/tag.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_widget/category.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_widget/recent_posts.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_widget/search.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_widget/tag.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_widget/tagcloud.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/about.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/after_footer.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/archive.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/article.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/comment.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/duoshuo_comment.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/footer.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/google_analytics.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/head.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/header.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/nav.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/pagination.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/sidebar.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/social.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/post/category.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/post/gallery.ejs","mtime":1414509878000},{"_id":"themes/cover/layout/_partial/post/share.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/post/tag.ejs","mtime":1414221112000},{"_id":"themes/cover/layout/_partial/post/title.ejs","mtime":1414509684000},{"_id":"themes/cover/layout/partial/about.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/after_footer.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/archive.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/article.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/comment.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/duoshuo_comment.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/footer.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/google_analytics.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/head.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/header.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/nav.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/pagination.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/sidebar.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/social.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/post/category.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/post/gallery.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/post/share.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/post/tag.ejs","mtime":1414247013000},{"_id":"themes/cover/layout/partial/post/title.ejs","mtime":1414247013000},{"_id":"themes/cover/source/background.jpg","mtime":1414221112000},{"_id":"themes/cover/source/favicon.ico","mtime":1413109243000},{"_id":"themes/cover/source/header.jpg","mtime":1414293369000},{"_id":"themes/cover/source/logo.png","mtime":1414293404000},{"_id":"themes/cover/source/fancybox/blank.gif","mtime":1414221112000},{"_id":"themes/cover/source/fancybox/fancybox_loading.gif","mtime":1414221112000},{"_id":"themes/cover/source/fancybox/fancybox_loading@2x.gif","mtime":1414221112000},{"_id":"themes/cover/source/fancybox/fancybox_overlay.png","mtime":1414221112000},{"_id":"themes/cover/source/fancybox/fancybox_sprite.png","mtime":1414221112000},{"_id":"themes/cover/source/fancybox/fancybox_sprite@2x.png","mtime":1414221112000},{"_id":"themes/cover/source/fancybox/jquery.fancybox.css","mtime":1414221112000},{"_id":"themes/cover/source/fancybox/jquery.fancybox.pack.js","mtime":1414221112000},{"_id":"themes/cover/source/js/bootstrap.min.js","mtime":1414221112000},{"_id":"themes/cover/source/js/cover.js","mtime":1414221112000},{"_id":"themes/cover/source/js/gallery.js","mtime":1414221112000},{"_id":"themes/cover/source/js/jquery.anystretch.min.js","mtime":1414221112000},{"_id":"themes/cover/source/js/jquery.imagesloaded.min.js","mtime":1414221112000},{"_id":"themes/cover/source/css/style.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_base/layout.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_base/utils.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_base/variable.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/archive.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/article.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/comment.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/footer.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/header.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/index.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/sidebar.styl","mtime":1414221112000},{"_id":"themes/cover/source/css/_partial/syntax.styl","mtime":1414221112000}],"Category":[{"name":"生活随笔","_id":"n2o51w1di78sz9iz","posts":["gyp2np96yk44xr49","6pkm2cc9kxp045bo","bhtgw1mzp3n1vmdk","z7qlgu39hxpntm3n","1ol6ccyqwa6d1xz1","uppvcja1j75dsczo","poch1sca6urhlcgz","4i9vnynit18v3nzm","vhh0v15cgu3bltjs"]},{"name":"读书","_id":"020pxy17uxp44hgo","posts":["y5o153pnrz1nos6r","d6lxxqks88yzo4xm"]},{"name":"golang","_id":"75xzcrceoqvh9mai","posts":["fqoyoqempc099ak9"]},{"name":"历史","_id":"k4v4w1iy6u1j422l","posts":["1neauukj3eyz29rm"]},{"name":"常识","_id":"5phamzh46ta4khxy","posts":["mn2c3ye0mz938ns7"]},{"name":"技巧","_id":"9vyyt45ulggql03a","posts":["9f4yjutby56sdhny"]},{"name":"语录","_id":"81d7osy8v4rwn4jg","posts":["vnvf5fguzcik5uqg"]}],"Page":[{"title":"books","date":1414233192000,"content":"<h3 id=\"book_list\">book list</h3>\n","source":"books/index.md","raw":"title: books\ndate: 2014-10-25 18:33:12\n---\n\n### book list\n\n","updated":1414233322000,"path":"books/index.html","excerpt":"","_id":"i2pgjcsjcbh9p2y0","comments":true,"layout":"page"},{"title":"books","date":1414243452000,"content":"<h3 id=\"test\">test</h3>\n","source":"books/test.md","raw":"title: books\ndate: 2014-10-25 21:24:12\n---\n\n### test\n","updated":1414243493000,"path":"books/test.html","excerpt":"","_id":"sg1stcygc425y7a8","comments":true,"layout":"page"},{"title":"friends","date":1414233463000,"content":"","source":"friends/index.md","raw":"title: friends\ndate: 2014-10-25 18:37:43\n---\n","updated":1414233463000,"path":"friends/index.html","excerpt":"","_id":"5pi18xidoas8pt6d","comments":true,"layout":"page"}],"Post":[{"title":"升级了，梓睿来了","date":1409153329000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>本来这篇文章因为在这个月7号晚上写的，但是太忙了，也太累了，一搁就是20天了，时间好不经用。公历2014年08月07日12：23(农历2014年7月12日)大公子何梓睿(小名：辰辰)出生了。体重5.7斤，这个提早一个月见父母的孩子，把他的父母吓的够呛，当然出生的那一刻，看着乌黑的头发，我就觉得他太争气了。本来我们是想23号剖腹的，结果孩子就是想生在狮子座,哈哈，霸气。幸苦辰辰的妈妈了，其实也不用老后悔没有顺从，母子平安，我就满足了！</p>\n<p>很多人都是有了宝宝之后，就是自己各种密码，头像都是宝宝的，我其实也差不多，头像已经是宝宝的了，就差把各种密码都换成孩子的了，你们觉得靠谱不？哈哈，想多了，密码的东西是不会换成。不过我想还是会给他申请一个QQ号码神马的，都对自己无语了。</p>\n<p>请假的这段时间，幸苦各位小朋友了，在此一一拜谢，就写到这里了。good night,大武汉</p>\n","source":"_posts/baby-come.md","raw":"title: 升级了，梓睿来了\ndate: 2014-08-27 23:28:49\ntags:\n- 生活\ncategories: \n- 生活随笔\n---\n\n本来这篇文章因为在这个月7号晚上写的，但是太忙了，也太累了，一搁就是20天了，时间好不经用。公历2014年08月07日12：23(农历2014年7月12日)大公子何梓睿(小名：辰辰)出生了。体重5.7斤，这个提早一个月见父母的孩子，把他的父母吓的够呛，当然出生的那一刻，看着乌黑的头发，我就觉得他太争气了。本来我们是想23号剖腹的，结果孩子就是想生在狮子座,哈哈，霸气。幸苦辰辰的妈妈了，其实也不用老后悔没有顺从，母子平安，我就满足了！\n\n很多人都是有了宝宝之后，就是自己各种密码，头像都是宝宝的，我其实也差不多，头像已经是宝宝的了，就差把各种密码都换成孩子的了，你们觉得靠谱不？哈哈，想多了，密码的东西是不会换成。不过我想还是会给他申请一个QQ号码神马的，都对自己无语了。\n\n请假的这段时间，幸苦各位小朋友了，在此一一拜谢，就写到这里了。good night,大武汉","slug":"baby-come","updated":1420817625000,"excerpt":"","_id":"gyp2np96yk44xr49","comments":true,"layout":"post","photos":[],"link":""},{"title":"写在宝宝出生之前","date":1407356606000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>从2点的电话响到现在，我一直很激动，也很不安。孩子太想见父母了，也很争气，是我们想生的狮子座。不安的是老婆在等医院车接的那十几分钟。虽然现在还不知道是男孩还是女孩，一样期待吧，看了一下武汉最早的车是6：45 。这几个小时一直在想，提前两周出生对孩子会不会有什么不好影响。此刻我脑子里闪过的都是老婆和孩子都平平安安就好，什么星座都是浮云。也许我赶到的时候孩子已经生了，希望孩子再争气一些，能等到我到了再生，感觉自己好天真。</p>\n<p>接下来会是一段忙碌的日子，对于前面文章写的我希望宝宝出生时，我的体重到60kg左右，孩子的提前到来，让我只能在他出生后演绎一个励志的故事，让他看着我瘦 ^_^ ,想想都有点小激动。</p>\n<p>对于近期工作上的事情，我最后还是选择做一个傻子，不知道看起来世故不？人生总有很多的无奈，我们能做的，就是做好自己，无奈自然会过去，我们都是没有伞的孩子，从小就必须努力奔跑。好在，越努力，越幸运！也让我们再幸运一把。也想趁小朋友出生的这段时间，放下工作上的东西，好好休息一下。</p>\n<p>以前听别人说的，小孩出生就把自己的各种密码都设成小孩的生日；各种有图片的地方都设成小孩的照片。我会怎么做尼，敬请期待吧 </p>\n","source":"_posts/before-baby-born.md","raw":"title: 写在宝宝出生之前\ndate: 2014-08-07 04:23:26\ntags:\n- 生活\ncategories: \n- 生活随笔\n\n---\n\n从2点的电话响到现在，我一直很激动，也很不安。孩子太想见父母了，也很争气，是我们想生的狮子座。不安的是老婆在等医院车接的那十几分钟。虽然现在还不知道是男孩还是女孩，一样期待吧，看了一下武汉最早的车是6：45 。这几个小时一直在想，提前两周出生对孩子会不会有什么不好影响。此刻我脑子里闪过的都是老婆和孩子都平平安安就好，什么星座都是浮云。也许我赶到的时候孩子已经生了，希望孩子再争气一些，能等到我到了再生，感觉自己好天真。\n\n接下来会是一段忙碌的日子，对于前面文章写的我希望宝宝出生时，我的体重到60kg左右，孩子的提前到来，让我只能在他出生后演绎一个励志的故事，让他看着我瘦 ^_^ ,想想都有点小激动。\n\n\n对于近期工作上的事情，我最后还是选择做一个傻子，不知道看起来世故不？人生总有很多的无奈，我们能做的，就是做好自己，无奈自然会过去，我们都是没有伞的孩子，从小就必须努力奔跑。好在，越努力，越幸运！也让我们再幸运一把。也想趁小朋友出生的这段时间，放下工作上的东西，好好休息一下。\n\n以前听别人说的，小孩出生就把自己的各种密码都设成小孩的生日；各种有图片的地方都设成小孩的照片。我会怎么做尼，敬请期待吧 ","slug":"before-baby-born","updated":1420817163000,"excerpt":"","_id":"6pkm2cc9kxp045bo","comments":true,"layout":"post","photos":[],"link":""},{"title":"《文明之光》读后感","date":1405869474000,"tags":["2krmfb4w4f626chk"],"categories":["020pxy17uxp44hgo"],"content":"<p>上个星期拜读完吴军博士的《文明之光》前两册，休息了一个礼拜。现在自己的博客也搭起来了，写写读书笔记貌似不错。废话少说，给我的感觉，这个两本书还是延续了《数学之美》和《浪潮之巅》的风格，一贯的好看和精彩。这两册从地球的形成讲到冷战的俄美的太空竞赛，我相信正如作者说说还会有第三册或者第三册，期待一下。</p>\n<p>开篇引子年轻的人类从主流的“康德－拉普拉斯星云说”，到现代人源于非洲南部，并从非洲南部迁徙和最早到欧洲到尼安德塔人共同生活，再到迁徙其他大陆，以至于除了非洲，我们都有10%左右尼安德塔人的基因，我们也算半个非洲人</p>\n<p>第一章讲述古埃及文明从金字塔到死亡之书，也让我知道了，为什么电影你都说的古埃及的法老为什么是数字王朝，因为他们的法老不会给自己取一个年号，就用数字编号了。原来金字塔是法老升天的梯子。</p>\n<p>第二章讲述车轮子，楔形文字和汉谟拉比法典的美索不达米亚文明，不管当时这个两河流域的文明地，经历了一波又一波不同种族的统治／灭忙的循环，他们的发明的冶铁技术和人类奇迹的空中花园现在还是为我们记录了这里的辉煌的文明。</p>\n<p>第三章从垄耕种植法和科举开始讲述中国的文明。高晓松讲中国特色的文明科举，青楼和镖局，更多的是故事。其实作者谈到的科举的创举和相对公平也是水到渠成的，古代中国科举是读书人上升的渠道，到现在的高科，可能最近听的比较多的就是寒门再难出贵子，深思深思。从宋朝是中国唯一没有农民起义就可以看出当时社会和人民的富裕，跟难能可贵的是居然，在一个农业国家，农业税的比例在降低，贸易税的比例在升高。可见清明上河图画的情景应该多半都是真的。可惜了宋家两度灭国，都是外敌（外族）入侵。</p>\n<p>第四章从毕达格拉斯的勾股定律到欧几里得的几何原本，几何学终于在欧几里得的原本里写成公理化体系。亚里士多得和他的弟子亚历山大的雅典学院让那一批聪明的人抱团，也产生了另一批伟大的科学家。阿基米德鉴定皇冠和浮力定律。托勒密的天文学，其实作者也写了关于英国李约瑟对中国人民对欧美以前的科学家会有评价的影响。</p>\n<p>第五章罗马人三次征服世界，不管前两次罗马帝国的皇帝有多么能征善战，最后一个还是罗马法统一了世界。不管是英美的英美法系，还是其他从德国的《普鲁士普通邦法典》的和法国《拿破仑法典》为基础的大陆法系都或多或少受到罗马法的影响。</p>\n<p>第六章从陶到瓷，讲述了上天眷顾的中国人讲瓷器烧出来并风靡全球，最后到被日本反超以及欧美的工业化模式的落败。固然有国运的衰败，但是作者提到的中国古代，不爱记录生产的数据，以及师父留一手的想法也真的让很多美好的东西失传了。</p>\n<p>第七章让我眼前一亮，文艺复兴真的在很大程度上跟一个叫美第奇家族息息相关。可能在中国真没有货币战争中说的罗斯财尔德家族有名。这个家族的资助让达芬奇和米开朗琪罗等这些大的艺术家给人类留下了很多宝贵的艺术财富，家族不在了，但是这些精神财富却一直都在。最后伽利略居然没有做两个铁球同时着地的实验，小时候学的东西瞬间报了。</p>\n<p>第八章大航海居然是因为西方人吃东西没有味道需要东方的孜然等配料才决定在陆路被垄断的前提下走海陆。哥伦布，达伽马和麦哲伦估计大家都还有点印象。不管他们是真的算错了，还是利益驱使或者说就是爱冒险，他们都做了自己想做的事情。其实当时欧洲贵族和王室的鼓励也有很大的影响。最后麦哲伦死在菲律宾这事还是有点坑爹，好不容易能有香料和瓷器了，人不在了。</p>\n<p>第九章作者用一章讲述了一个还真理海边玩耍的孩子，当然他也站在巨人的肩膀上——牛顿。原来苹果没有那么夸张的砸到他的头，所有他也不需要咬一口。什么都不说了，写上碑文：自然和自然规律隐没在黑暗中，神说，让牛顿去吧！万物遂成光明 —— 亚历山大.波普</p>\n<p>第十章从短暂的葡、西时代到海上马车夫发家的荷兰，最后从维多利亚女王崛起的日不落帝国，真的值得思考：为什么不是无敌舰队的西班牙而是小小的荷兰统治了世界两百年？工业革命为什么会发生在英国？你有想过吗？</p>\n<p>第十一章主要写了美国的建国过程，谈出来的国家。也是美国这些国父们，先贤们缔造了这个年轻，自由的国度。原来那个用风筝做闪电实验的富兰克林居然还是美国的政治家。</p>\n<p>第十二章从笛卡尔到达尔文，写了工业革命前后科学技术的发展。主要还是一些科学家对科学研究方法论的阐述和方法论的影响。</p>\n<p>第十三章从铁路到电报，从电话到现代通信技术和产品的诞生和进入中国，很多东西在《信息简史》中可以看到更多的细节。</p>\n<p>第十四章电的发现和使用从电和磁的关系，到第二次工业革命，最后到核聚变发电。我们现代的生活真是离不电了。</p>\n<p>第十五章从迈特纳发现核裂变，当然中间还有一个狗血剧情，就是迈特纳在无解的时候看到窗外的水珠被一分为二就发现了核裂变-_-#。西拉德和爱因斯坦跟没有原子弹的故事估计大家也了解一些。最后潘多拉魔盒被打开后其实是把双刃剑，作者最后以法国为例鼓励使用核能发电。</p>\n<p>第十六章冷战时期苏美两国的军备竞赛，到太空竞赛。前战俘冯＊布劳恩和囚犯科罗缪夫为负责人的美苏，以苏联人造卫星和载人航天胜利，以及美国的登月完胜而告终。当然加加林和阿姆斯特朗已经写入历史，还有阿姆斯特朗的那句话：这是一个人的一小步，却是人类的一大步。</p>\n<p>我就这么粗的回顾了一下书中的内容，其实还是很推荐大家读的。特别是科技与文人结合的好书。作者从开始就说了文明的定义的：在西方学术界，阶级的产生和城市的出现，就意味着文明的开始。大部分学者认同的观点是一种文明的开始必须要有城市的遗迹作为佐证。文明的另一个佐证就是文字的记载，对于没有文字记载的历史，我们常常称为事前。总结作者书中的内容：文明具有传承性，从南非到尼罗河的埃及文明，在到两河流域的美索不达美亚，再到中国，再到地中海文明，然后是阿拉伯文明。当然也要谢谢这些传播者。文明具有群众性，文明不是没有帝王所作所为，不管是留下的建筑奇迹，还是艺术作品，富人或者帝王都只是自助，真正的创造者还是人民群众。</p>\n<p>有句话叫：看一个人接下来的十年看他晚上的两小时；看一个人的一辈子看他早上的一小时。晚安，武汉</p>\n","source":"_posts/civiliztion-and-enlightenments.md","raw":"title: 《文明之光》读后感\ndate: 2014-07-20 23:17:54\ntags:\n- 生活\ncategories: \n- 读书\n---\n上个星期拜读完吴军博士的《文明之光》前两册，休息了一个礼拜。现在自己的博客也搭起来了，写写读书笔记貌似不错。废话少说，给我的感觉，这个两本书还是延续了《数学之美》和《浪潮之巅》的风格，一贯的好看和精彩。这两册从地球的形成讲到冷战的俄美的太空竞赛，我相信正如作者说说还会有第三册或者第三册，期待一下。\n\n开篇引子年轻的人类从主流的“康德－拉普拉斯星云说”，到现代人源于非洲南部，并从非洲南部迁徙和最早到欧洲到尼安德塔人共同生活，再到迁徙其他大陆，以至于除了非洲，我们都有10%左右尼安德塔人的基因，我们也算半个非洲人\n\n第一章讲述古埃及文明从金字塔到死亡之书，也让我知道了，为什么电影你都说的古埃及的法老为什么是数字王朝，因为他们的法老不会给自己取一个年号，就用数字编号了。原来金字塔是法老升天的梯子。\n\n第二章讲述车轮子，楔形文字和汉谟拉比法典的美索不达米亚文明，不管当时这个两河流域的文明地，经历了一波又一波不同种族的统治／灭忙的循环，他们的发明的冶铁技术和人类奇迹的空中花园现在还是为我们记录了这里的辉煌的文明。\n\n第三章从垄耕种植法和科举开始讲述中国的文明。高晓松讲中国特色的文明科举，青楼和镖局，更多的是故事。其实作者谈到的科举的创举和相对公平也是水到渠成的，古代中国科举是读书人上升的渠道，到现在的高科，可能最近听的比较多的就是寒门再难出贵子，深思深思。从宋朝是中国唯一没有农民起义就可以看出当时社会和人民的富裕，跟难能可贵的是居然，在一个农业国家，农业税的比例在降低，贸易税的比例在升高。可见清明上河图画的情景应该多半都是真的。可惜了宋家两度灭国，都是外敌（外族）入侵。\n\n第四章从毕达格拉斯的勾股定律到欧几里得的几何原本，几何学终于在欧几里得的原本里写成公理化体系。亚里士多得和他的弟子亚历山大的雅典学院让那一批聪明的人抱团，也产生了另一批伟大的科学家。阿基米德鉴定皇冠和浮力定律。托勒密的天文学，其实作者也写了关于英国李约瑟对中国人民对欧美以前的科学家会有评价的影响。\n\n第五章罗马人三次征服世界，不管前两次罗马帝国的皇帝有多么能征善战，最后一个还是罗马法统一了世界。不管是英美的英美法系，还是其他从德国的《普鲁士普通邦法典》的和法国《拿破仑法典》为基础的大陆法系都或多或少受到罗马法的影响。\n\n第六章从陶到瓷，讲述了上天眷顾的中国人讲瓷器烧出来并风靡全球，最后到被日本反超以及欧美的工业化模式的落败。固然有国运的衰败，但是作者提到的中国古代，不爱记录生产的数据，以及师父留一手的想法也真的让很多美好的东西失传了。\n\n第七章让我眼前一亮，文艺复兴真的在很大程度上跟一个叫美第奇家族息息相关。可能在中国真没有货币战争中说的罗斯财尔德家族有名。这个家族的资助让达芬奇和米开朗琪罗等这些大的艺术家给人类留下了很多宝贵的艺术财富，家族不在了，但是这些精神财富却一直都在。最后伽利略居然没有做两个铁球同时着地的实验，小时候学的东西瞬间报了。\n\n第八章大航海居然是因为西方人吃东西没有味道需要东方的孜然等配料才决定在陆路被垄断的前提下走海陆。哥伦布，达伽马和麦哲伦估计大家都还有点印象。不管他们是真的算错了，还是利益驱使或者说就是爱冒险，他们都做了自己想做的事情。其实当时欧洲贵族和王室的鼓励也有很大的影响。最后麦哲伦死在菲律宾这事还是有点坑爹，好不容易能有香料和瓷器了，人不在了。\n\n第九章作者用一章讲述了一个还真理海边玩耍的孩子，当然他也站在巨人的肩膀上——牛顿。原来苹果没有那么夸张的砸到他的头，所有他也不需要咬一口。什么都不说了，写上碑文：自然和自然规律隐没在黑暗中，神说，让牛顿去吧！万物遂成光明 —— 亚历山大.波普\n\n第十章从短暂的葡、西时代到海上马车夫发家的荷兰，最后从维多利亚女王崛起的日不落帝国，真的值得思考：为什么不是无敌舰队的西班牙而是小小的荷兰统治了世界两百年？工业革命为什么会发生在英国？你有想过吗？\n\n第十一章主要写了美国的建国过程，谈出来的国家。也是美国这些国父们，先贤们缔造了这个年轻，自由的国度。原来那个用风筝做闪电实验的富兰克林居然还是美国的政治家。\n\n第十二章从笛卡尔到达尔文，写了工业革命前后科学技术的发展。主要还是一些科学家对科学研究方法论的阐述和方法论的影响。\n\n第十三章从铁路到电报，从电话到现代通信技术和产品的诞生和进入中国，很多东西在《信息简史》中可以看到更多的细节。\n\n第十四章电的发现和使用从电和磁的关系，到第二次工业革命，最后到核聚变发电。我们现代的生活真是离不电了。\n\n第十五章从迈特纳发现核裂变，当然中间还有一个狗血剧情，就是迈特纳在无解的时候看到窗外的水珠被一分为二就发现了核裂变-_-#。西拉德和爱因斯坦跟没有原子弹的故事估计大家也了解一些。最后潘多拉魔盒被打开后其实是把双刃剑，作者最后以法国为例鼓励使用核能发电。\n\n第十六章冷战时期苏美两国的军备竞赛，到太空竞赛。前战俘冯＊布劳恩和囚犯科罗缪夫为负责人的美苏，以苏联人造卫星和载人航天胜利，以及美国的登月完胜而告终。当然加加林和阿姆斯特朗已经写入历史，还有阿姆斯特朗的那句话：这是一个人的一小步，却是人类的一大步。\n\n我就这么粗的回顾了一下书中的内容，其实还是很推荐大家读的。特别是科技与文人结合的好书。作者从开始就说了文明的定义的：在西方学术界，阶级的产生和城市的出现，就意味着文明的开始。大部分学者认同的观点是一种文明的开始必须要有城市的遗迹作为佐证。文明的另一个佐证就是文字的记载，对于没有文字记载的历史，我们常常称为事前。总结作者书中的内容：文明具有传承性，从南非到尼罗河的埃及文明，在到两河流域的美索不达美亚，再到中国，再到地中海文明，然后是阿拉伯文明。当然也要谢谢这些传播者。文明具有群众性，文明不是没有帝王所作所为，不管是留下的建筑奇迹，还是艺术作品，富人或者帝王都只是自助，真正的创造者还是人民群众。\n\n有句话叫：看一个人接下来的十年看他晚上的两小时；看一个人的一辈子看他早上的一小时。晚安，武汉","slug":"civiliztion-and-enlightenments","updated":1420816868000,"excerpt":"","_id":"y5o153pnrz1nos6r","comments":true,"layout":"post","photos":[],"link":""},{"title":"上线的那些事2","date":1419171577000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>接着上一篇《上线的那些事》，今天写第二篇，主要有两个原因：第一.12月16号《完美神话》渠道首发，第二.首发当天各种很low的问题。一推再推，手游终于在12月16号上了14个联运渠道，从邮件得出的消息，这个第一款游戏，也是花了一年多3个月的时间开发出来的游戏在渠道获得的评级大部分是B+，小部分是A。我们总是以我们是新手为借口走过了15个月，现在游戏上线了。第一天从渠道来的量大概4千多左右，可以理解B＋级的游戏，渠道不可能倒量太多的。很多的说法，比如B＋的游戏只要不出现重大的运营事故，基本上可以养活自己什么的。我估计要花一点时间去弄明白游戏在渠道的评级了。</p>\n<p>首发当天，出现了几个问题，第一个是充值给多倍元宝的问题；第二个问题是充值不到账的问题；第三个问题是月卡购买不了的问题，这些问题都跟充值有关，也就是跟钱有关系。最后这些问题多临时解决了，当然问题的原因也就是开发人员没有注意一些重要的约定，第二个就是测试真的不充分，每次都拿一块钱测试，很多的测试分支都没有测试过。说到最后测试都用一块钱是因为报账的时候需要很麻烦的手续和各种自己要去弄的发票。</p>\n<p>虽然做了一年多，渠道首发一推在推，但是从这次首发的表现上看，我觉得我们还没有准备好。做为参与其中的人，作为开发者，我觉得我们团队出现的这些很low的错误，真的很难让人接受。其实我们真的不是新手了，不能再用这个来当借口了。事在人为，可能时间有点长，大家这段时间的士气不是很高有一些影响，总体来说，渠道发出去了，也是大家的一次进步，希望以后越来越好了。</p>\n<p>加油了，完美神话。</p>\n","source":"_posts/game-published.md","raw":"title: 上线的那些事2\ndate: 2014-12-21 22:19:37\ntags:\n- 生活\ncategories: \n- 生活随笔\n\n---\n接着上一篇《上线的那些事》，今天写第二篇，主要有两个原因：第一.12月16号《完美神话》渠道首发，第二.首发当天各种很low的问题。一推再推，手游终于在12月16号上了14个联运渠道，从邮件得出的消息，这个第一款游戏，也是花了一年多3个月的时间开发出来的游戏在渠道获得的评级大部分是B+，小部分是A。我们总是以我们是新手为借口走过了15个月，现在游戏上线了。第一天从渠道来的量大概4千多左右，可以理解B＋级的游戏，渠道不可能倒量太多的。很多的说法，比如B＋的游戏只要不出现重大的运营事故，基本上可以养活自己什么的。我估计要花一点时间去弄明白游戏在渠道的评级了。\n\n\n首发当天，出现了几个问题，第一个是充值给多倍元宝的问题；第二个问题是充值不到账的问题；第三个问题是月卡购买不了的问题，这些问题都跟充值有关，也就是跟钱有关系。最后这些问题多临时解决了，当然问题的原因也就是开发人员没有注意一些重要的约定，第二个就是测试真的不充分，每次都拿一块钱测试，很多的测试分支都没有测试过。说到最后测试都用一块钱是因为报账的时候需要很麻烦的手续和各种自己要去弄的发票。\n\n\n虽然做了一年多，渠道首发一推在推，但是从这次首发的表现上看，我觉得我们还没有准备好。做为参与其中的人，作为开发者，我觉得我们团队出现的这些很low的错误，真的很难让人接受。其实我们真的不是新手了，不能再用这个来当借口了。事在人为，可能时间有点长，大家这段时间的士气不是很高有一些影响，总体来说，渠道发出去了，也是大家的一次进步，希望以后越来越好了。\n\n加油了，完美神话。","slug":"game-published","updated":1419172736000,"excerpt":"","_id":"bhtgw1mzp3n1vmdk","comments":true,"layout":"post","photos":[],"link":""},{"title":"Go 在谷歌：以软件工程为目的的语言设计(转)","date":1403536176000,"tags":["twq4t4wsw1wesux9"],"categories":["75xzcrceoqvh9mai"],"content":"<h2 id=\"1-_摘要\">1. 摘要</h2>\n<p>(本文是根据Rob Pike于2012年10月25日在Tucson, Arizona举行的SPLASH 2012大会上所做的主题演讲进行修改后所撰写的。)<br>针对我们在Google公司内开发软件基础设施时遇到的一些问题，我们于2007年末构思出Go编程语言。当今的计算领域同创建如今所使用的编程语言（使用最多的有C++、Java和Python）时的环境几乎没什么关系了。由多核处理器、系统的网络化、大规模计算机集群和Web编程模型带来的编程问题都是以迂回的方式而不是迎头而上的方式解决的。此外，程序的规模也已发生了变化：现在的服务器程序由成百上千甚至成千上万的程序员共同编写，源代码也以数百万行计，而且实际上还需要每天都进行更新。更加雪上加霜的是，即使在大型编译集群之上进行一次build，所花的时间也已长达数十分钟甚至数小时。<br>之所以设计开发Go，就是为了提高这种环境下的工作效率。Go语言设计时考虑的因素，除了大家较为了解的内置并发和内存垃圾自动回收这些方面之外，还包括严格的依赖管理、对随系统增大而在体系结构方面发生变化的适应性、跨组件边界的健壮性（robustness）。<br>本文将详细讲解在构造一门轻量级并让人感觉愉悦的、高效的编译型编程语言时，这些问题是如何得到解决的。讲解过程中使用的例子都是来自Google公司中所遇到的现实问题。</p>\n<h2 id=\"2-_简介\">2. 简介</h2>\n<p>Go语言开发自Google，是一门支持并发编程和内存垃圾回收的编译型静态类型语言。它是一个开源的项目：Google从公共的代码库中导入代码而不是相反。<br>Go语言运行效率高，具有较强的可伸缩性(scalable)，而且使用它进行工作时的效率也很高。有些程序员发现用它编程很有意思；还有一些程序员认为它缺乏想象力甚至很烦人。在本文中我们将解释为什么这两种观点并不相互矛盾。Go是为解决Google在软件开发中遇到的问题而设计的，虽然因此而设计出的语言不会是一门在研究领域里具有突破性进展的语言，但它却是大型软件项目中软件工程方面的一个非常棒的工具。</p>\n<h2 id=\"3-_Google公司中的Go语言\">3. Google公司中的Go语言</h2>\n<p>为了帮助解决Google自己的问题，Google设计了Go这门编程语言，可以说，Google有很大的问题。<br>硬件的规模很大而且软件的规模也很大。软件的代码行数以百万计，服务器软件绝大多数用的是C++，还有很多用的是Java，剩下的一部分还用到了Python。成千上万的工程师在这些代码上工作，这些代码位于由所有软件组成的一棵树上的“头部”，所以每天这棵树的各个层次都会发生大量的修改动作。尽管使用了一个大型自主设计的分布式Build系统才让这种规模的开发变得可行，但这个规模还是太大 了。<br>当然，所有这些软件都是运行在无数台机器之上的，但这些无数台的机器只是被看做数量并不多若干互相独立而仅通过网络互相连接的计算机集群。<br>简言之，Google公司的开发规模很大，速度可能会比较慢，看上去往往也比较笨拙。但很有效果。<br>Go项目的目标是要消除Google公司软件开发中的慢速和笨拙，从而让开发过程更加高效并且更加具有可伸缩性。该语言的设计者和使用者都是要为大型软件系统编写、阅读和调试以及维护代码的人。<br>因此，Go语言的目的不是要在编程语言设计方面进行科研；它要能为它的设计者以及设计者的同事们改善工作环境。Go语言考虑更多的是软件工程而不是编程语言方面的科研。或者，换句话说，它是为软件工程服务而进行的语言设计。<br>但是，编程语言怎么会对软件工程有所帮助呢？下文就是该问题的答案。</p>\n<h2 id=\"4-_痛之所在\">4. 痛之所在</h2>\n<p>当Go刚推出来时，有人认为它缺乏某些大家公认的现代编程语言中所特有的特性或方法论。缺了这些东西，Go语言怎么可能会有存在的价值？我们回答这个问题的答案在于，Go的确具有一些特性，而这些特性可以解决困扰大规模软件开发的一些问题。这些问题包括：</p>\n<pre><code><span class=\"bullet\">* </span>Build速度缓慢\n<span class=\"bullet\">* </span>失控的依赖关系\n<span class=\"bullet\">* </span>每个程序员使用同一门语言的不同子集\n<span class=\"bullet\">* </span>程序难以理解（代码难以阅读，文档不全面等待）\n<span class=\"bullet\">* </span>很多重复性的劳动\n<span class=\"bullet\">* </span>更新的代价大\n<span class=\"bullet\">* </span>版本偏斜（version skew）\n<span class=\"bullet\">* </span>难以编写自动化工具\n<span class=\"bullet\">* </span>语言交叉Build（cross-language build）产生的问题\n</code></pre><p>一门语言每个单个的特性都解决不了这些问题。这需要从软件工程的大局观，而在Go语言的设计中我们试图致力于解决所有这些问题。<br>举个简单而独立的例子，我们来看看程序结果的表示方式。有些评论者反对Go中使用象C一样用花括号表示块结构，他们更喜欢Python或Haskell风格式，使用空格表示缩进。可是，我们无数次地碰到过以下这种由语言交叉Build造成的Build和测试失败：通过类似SWIG调用的方式，将一段Python代码嵌入到另外一种语言中，由于修改了这段代码周围的一些代码的缩进格式，从而导致Python代码也出乎意料地出问题了并且还非常难以觉察。 因此，我们的观点是，虽然空格缩进对于小规模的程序来说非常适用，但对大点的程序可不尽然，而且程序规模越大、代码库中的代码语言种类越多，空格缩进造成的问题就会越多。为了安全可靠，舍弃这点便利还是更好一点，因此Go采用了花括号表示的语句块。</p>\n<h2 id=\"5-C和C++中的依赖\">5.C和C++中的依赖</h2>\n<p>在处理包依赖（package dependency）时会出现一些伸缩性以及其它方面的问题，这些问题可以更加实质性的说明上个小结中提出的问题。让我们先来回顾一下C和C++是如何处理包依赖的。<br>ANSI C第一次进行标准化是在1989年，它提倡要在标准的头文件中使用#ifndef这样的”防护措施”。 这个观点现已广泛采用，就是要求每个头文件都要用一个条件编译语句（clause）括起来，这样就可以将该头文件包含多次而不会导致编译错误。比如，Unix中的头文件<sys stat.h=\"\">看上去大致是这样的：<br>1/<em> Large copyright and licensing notice </em>/<br>2#ifndef <em>SYS_STAT_H</em><br>3#define <em>SYS_STAT_H</em><br>4/<em> Types and other definitions </em>/<br>5#endif</sys></p>\n<p>此举的目的是让C的预处理器在第二次以及以后读到该文件时要完全忽略该头文件。符号<em>SYS_STAT_H</em>在文件第一次读到时进行定义，可以“防止”后继的调用。<br>这么设计有一些好处，最重要的是可以让每个头文件能够安全地include它所有的依赖，即时其它的头文件也有同样的include语句也不会出问题。 如果遵循此规则，就可以通过对所有的#include语句按字母顺序进行排序，让代码看上去更整洁。<br>但是，这种设计的可伸缩性非常差。</p>\n<p>在1984年，有人发现在编译Unix中ps命令的源程序ps.c时，在整个的预处理过程中，它包含了<sys stat.h=\"\">这个头文件37次之多。尽管在这么多次的包含中有36次它的文件的内容都不会被包含进来，但绝大多数C编译器实现都会把”打开文件并读取文件内容然后进行字符串扫描”这串动作做37遍。这么做可真不聪明，实际上，C语言的预处理器要处理的宏具有如此复杂的语义，其势必导致这种行为。<br>对软件产生的效果就是在C程序中不断的堆积#include语句。多加一些#include语句并不会导致程序出问题，而且想判断出其中哪些是再也不需要了的也很困难。删除一条#include语句然后再进行编译也不太足以判断出来，因为还可能有另外一条#include所包含的文件中本身还包含了你刚刚删除的那条#include语句。<br>从技术角度讲，事情并不一定非得弄成这样。在意识到使用#ifndef这种防护措施所带来的长期问题之后，Plan 9的library的设计者采取了一种不同的、非ANSI标准的方法。Plan 9禁止在头文件中使用#include语句，并要求将所有的#include语句放到顶层的C文件中。 当然，这么做需要一些训练 —— 程序员需要一次列出所有需要的依赖，还要以正确的顺序排列 —— 但是文档可以帮忙而且实践中效果也非常好。这么做的结果是，一个C源程序文件无论需要多少依赖，在对它进行编译时，每个#include文件只会被读一次。当然，这样一来，对于任何#include语句都可以通过先拿掉然后在进行编译的方式判断出这条#include语句到底有无include的必要：当且仅当不需要该依赖时，拿掉#include后的源程序才能仍然可以通过编译。</sys></p>\n<p>Plan 9的这种方式产生的一个最重要的结果是编译速度比以前快了很多：采用这种方式后编译过程中所需的I/O量，同采用#ifndef的库相比，显著地减少了不少。<br>但在Plan 9之外，那种“防护”式的方式依然是C和C++编程实践中大家广为接受的方式。实际上，C++还恶化了该问题，因为它把这种防护措施使用到了更细的粒度之上。按照惯例，C++程序通常采用每个类或者一小组相关的类拥有一个头文件这种结构，这种分组方式要更小，比方说，同<stdio.h>相比要小。因而其依赖树更加错综复杂，它反映的不是对库的依赖而是对完整类型层次结构的依赖。而且，C++的头文件通常包含真正的代码 —— 类型、方法以及模板声明 ——不像一般的C语言头文件里面仅仅有一些简单的常量定义和函数签名。这样，C++就把更多的工作推给了编译器，这些东西编译起来要更难一些，而且每次编译时编译器都必须重复处理这些信息。当要build一个比较大型的C++二进制程序时，编译器可能需要成千上万次地处理头文件<string>以了解字符串的表示方式。（根据当时的记录，大约在1984年，Tom Cargill说道，在C++中使用C预处理器来处理依赖管理将是个长期的不利因素，这个问题应该得到解决。）</string></stdio.h></p>\n<p>在Google，Build一个单个的C++二进制文件就能够数万次地打开并读取数百个头文件中的每个头文件。在2007年，Google的build工程师们编译了一次Google里一个比较主要的C++二进制程序。该文件包含了两千个文件，如果只是将这些文件串接到一起，总大型为4.2M。将#include完全扩展完成后，就有8G的内容丢给编译器编译，也就是说，C++源代码中的每个自己都膨胀成到了2000字节。 还有一个数据是，在2003年Google的Build系统转变了做法，在每个目录中安排了一个Makefile，这样可以让依赖更加清晰明了并且也能好的进行管理。一般的二进制文件大小都减小了40%，就因为记录了更准确的依赖关系。即使如此，C++（或者说C引起的这个问题）的特性使得自动对依赖关系进行验证无法得以实现，直到今天我们仍然我发准确掌握Google中大型的C++二进制程序的依赖要求的具体情况。</p>\n<p>由于这种失控的依赖关系以及程序的规模非常之大，所以在单个的计算机上build出Google的服务器二进制程序就变得不太实际了，因此我们创建了一个大型分布式编译系统。该系统非常复杂（这个Build系统本身也是个大型程序）还使用了大量机器以及大量缓存，藉此在Google进行Build才算行得通了，尽管还是有些困难。 即时采用了分布式Build系统，在Google进行一次大规模的build仍需要花几十分钟的时间才能完成。前文提到的2007年那个二进制程序使用上一版本的分布式build系统花了45分钟进行build。现在所花的时间是27分钟，但是，这个程序的长度以及它的依赖关系在此期间当然也增加了。为了按比例增大build系统而在工程方面所付出的劳动刚刚比软件创建的增长速度提前了一小步。</p>\n<h2 id=\"6-_走进_Go_语言\">6. 走进 Go 语言</h2>\n<p>当编译缓慢进行时，我们有充足的时间来思考。关于 Go 的起源有一个传说，话说正是一次长达45分钟的编译过程中，Go 的设想出现了。人们深信，为类似谷歌网络服务这样的大型程序编写一门新的语言是很有意义的，软件工程师们认为这将极大的改善谷歌程序员的生活质量。<br>尽管现在的讨论更专注于依赖关系，这里依然还有很多其他需要关注的问题。这一门成功语言的主要因素是：</p>\n<pre><code>* 它必须适应于大规模开发，如拥有大量依赖的大型程序，且又一个很大的程序员团队为之工作。\n\n\n* 它必须是熟悉的，大致为 <span class=\"keyword\">C</span> 风格的。谷歌的程序员在职业生涯的早期，对函数式语言，特别是 <span class=\"keyword\">C</span> 家族更加熟稔。要想程序员用一门新语言快速开发，新语言的语法不能过于激进。\n\n\n* 它必须是现代的。<span class=\"keyword\">C</span>、<span class=\"keyword\">C</span>++以及Java的某些方面，已经过于老旧，设计于多核计算机、网络和网络应用出现之前。新方法能够满足现代世界的特性，例如内置的并发。\n</code></pre><p>说完了背景，现在让我们从软件工程的角度谈一谈 Go 语言的设计。</p>\n<h2 id=\"7-_Go_语言的依赖处理\">7. Go 语言的依赖处理</h2>\n<p>既然我们谈及了很多C 和 C++ 中依赖关系处理细节，让我们看看 Go 语言是如何处理的吧。在语义和语法上，依赖处理是由语言定义的。它们是明确的、清晰的、且“能被计算的”，就是说，应该很容易被编写工具分析。<br>在包封装（下节的主题）之后，每个源码文件都或有至少一个引入语句，包括 import 关键词和一个用来明确当前（只是当前）文件引入包的字符串：<br>import “encoding/json”</p>\n<p>使 Go 语言规整的第一步就是：睿智的依赖处理，在编译阶段，语言将未被使用的依赖视为错误（并非警告，是错误）。如果源码文件引入一个包却没有使用它，程序将无法完成编译。这将保证 Go 程序的依赖关系是明确的，没有任何多余的边际。另一方面，它可以保证编译过程不会包含无用代码，降低编译消耗的时间。</p>\n<p>第二步则是由编译器实现的，它将通过深入依赖关系确保编译效率。设想一个含有三个包的 Go 程序，其依赖关系如下：</p>\n<pre><code><span class=\"bullet\">* </span>A 包 引用 B 包;\n<span class=\"bullet\">* </span>B 包 引用 C 包;\n<span class=\"bullet\">* </span>A 包 不引用 C 包\n</code></pre><p>这就意味着，A 包对 C 包的调用是由对 B 包的调用间接实现的;也就是说，在 A 包的代码中，不存在 C 包的标识符。例如，C 包中有一个类型定义，它是 B 包中的某个为 A 包调用的结构体中的字段类型，但其本身并未被 A 包调用。具一个更实际的例子，设想一下，A 包引用了一个 格式化 I/O 包 B，B 包则引用了 C 包提供的缓冲 I/O 实现，A 包本身并没有声明缓冲 I/O。</p>\n<p>要编译这个程序，首先 C 被编译，被依赖的包必须在依赖于它们的包之前被编译。之后 B 包被编译;最后 A 包被编译，然后程序将被连接。<br>当 A 包编译完成之后，编译器将读取 B 包的目标文件，而不是代码。此目标文件包含编译器处理 A 包代码中<br>import “B”</p>\n<p>语句所需的所有类型信息。这些信息也包含着 B 包在编译是所需的 C 包的信息。换句话说，当 B 包被编译时，生成的目标文件包含了所有 B 包公共接口所需的全部依赖的类型信息。<br>这种设计拥有很重要的意义，当编译器处理 import 语句时，它将打开一个文件——该语句所明确的对象文件。当然，这不由的让人想起 Plan 9 C （非 ANSI C）对依赖管理方法，但不同的是，当 Go 代码文件被编译完成时，编译器将写入头文件。同 Plan 9 C 相比，这个过程将更自动化、更高效，因为：在处理 import 时读取的数据只是“输出”数据，而非程序代码。这对编译效率的影响是巨大的，而且，即便代码增长，程序依然规整如故。处理依赖树并对之编译的时间相较于 C 和 C++ 的“引入被引用文件”的模型将极大的减少。</p>\n<p>值得一提的是，这个依赖管理的通用方法并不是原始的；这些思维要追溯到1970年代的像Modula-2和Ada语言。在C语言家族里，Java就包含这一方法的元素。<br>为了使编译更加高效，对象文件以导出数据作为它的首要步骤，这样编译器一旦到达文件的末尾就可以停止读取。这种依赖管理方法是为什么Go编译比C或C++编译更快的最大原因。另一个因素是Go语言把导出数据放在对象文件中；而一些语言要求程序员编写或让编译器生成包含这一信息的另一个文件。这相当于两次打开文件。在Go语言中导入一个程序包只需要打开一次文件。并且，单一文件方法意味着导出数据（或在C/C++的头文件）相对于对象文件永远不会过时。</p>\n<p>为了准确起见，我们对Google中用Go编写的某大型程序的编译进行了测算，将源代码的展开情况同前文中对C++的分析做一对比。结果发现是40倍，要比C++好50倍（同样也要比C++简单因而处理速度也快），但是这仍然比我们预期的要大。原因有两点。第一，我们发现了一个bug：Go编译器在export部分产生了大量的无用数据。第二，export数据采用了一种比较冗长的编码方式，还有改善的余地。我们正计划解决这些问题。<br>然而，仅需作50分之1的事情就把原来的Build时间从分钟级的变为秒级的，将咖啡时间转化为交互式build。<br>Go的依赖图还有另外一个特性，就是它不包含循环。Go语言定义了不允许其依赖图中有循环性的包含关系，编译器和链接器都会对此进行检查以确保不存在循环依赖。虽然循环依赖偶尔也有用，但它在大规模程序中会引入巨大的问题。循环依赖要求编译器同时处理大量源文件，从而会减慢增量式build的速度。更重要的是，如果允许循环依赖，我们的经验告诉我们，这种依赖最后会形成大片互相纠缠不清的源代码树，从而让树中各部分也变得很大，难以进行独立管理，最后二进制文件会膨胀，使得软件开发中的初始化、测试、重构、发布以及其它一些任务变得过于复杂。</p>\n<p>不支持循环import偶尔会让人感到苦恼，但却能让依赖树保持清晰明了，对package的清晰划分也提了个更高的要求。就象Go中其它许多设计决策一样，这会迫使程序员早早地就对一些大规模程序里的问题提前进行思考（在这种情况下，指的是package的边界），而这些问题一旦留给以后解决往往就会永远得不到满意的解决。 在标准库的设计中，大量精力花在了控制依赖关系上了。为了使用一个函数，把所需的那一小段代码拷贝过来要比拉进来一个比较大的库强（如果出现新的核心依赖的话，系统build里的一个test会报告问题）。在依赖关系方面保持良好状况要比代码重用重要。在实践中有这样一个例子，底层的网络package里有自己的整数到小数的转换程序，就是为了避免对较大的、依赖关系复杂的格式化I/O package的依赖。还有另外一个例子，字符串转换package的strconv拥有一个对‘可打印’字符的进行定义的private实现，而不是将整个大哥的Unicode字符类表格拖进去， strconv里的Unicode标准是通过package的test进行验证的。</p>\n<h2 id=\"8-_包\">8. 包</h2>\n<p>Go 的包系统设计结合了一些库、命名控件和模块的特性。<br>每个 Go 的代码文件，例如“encoding/json/json.go”，都以包声明开始，如同：<br>package json</p>\n<p>“json” 就是“包名称”，一个简单的识别符号。通常包名称都比较精炼。<br>要使用包，使用 import 声明引入代码，并以 包路径 区分。“路径”的意义并未在语言中指定，而是约定为以/分割的代码包目录路径，如下：<br>import “encoding/json”</p>\n<p>后面用包名称（有别于路径）则用来限定引入自代码文件中包的条目。<br>var dec = json.NewDecoder(reader)</p>\n<p>这种设计非常清晰，从语法（Namevs.pkg.Name）上就能识别一个名字是否属于某个包（在此之后）。<br>在我们的示例中，包的路径是“encoding/json”而包的名称是 json。标准资源库以外，通常约定以项目或公司名作为命名控件的根：<br>import “google/base/go/log”</p>\n<p>确认包路径的唯一性非常重要，而对包名称则不必强求。包必须通过唯一的路径引入，而包名称则为引用者调用内容方式的一个约定。包名称不必唯一，可以通过引入语句重命名识别符。下面有两个自称为“package log”的包，如果要在单个源码文件中引入，需要在引入时重命名一个。<br>import “log”                          // Standard package<br>import googlelog “google/base/go/log” // Google-specific package</p>\n<p>每个公司都可能有自己的 log 包，不必要特别命名。恰恰相反：Go 的风格建议包名称保持简短和清晰，且不必担心冲突。<br>另一个例子：在 Google 代码库中有很多server 库。</p>\n<h2 id=\"9-_远程包\">9. 远程包</h2>\n<p>Go的包管理系统的一个重要特性是包路径，通常是一个字符串，通过识别 网站资源的URL 可以增加远程存储库。<br>下面就是如何使用储存在 github 上的包。go get 命令使用 go 编译工具获取资源并安装。一旦安装完毕，就可以如同其它包一样引用它。<br>$ go get github.com/4ad/doozer // Shell command to fetch package</p>\n<p>import “github.com/4ad/doozer” // Doozer client’s import statement</p>\n<p>var client doozer.Conn         // Client’s use of package</p>\n<p>这是值得注意的，go get 命令递归下载依赖，此特性得以实现的原因就是依赖关系的明确性。另外，由于引入路径的命名空间依赖于 URL，使得 Go 相较于其它语言，在包命名上更加分散和易于扩展。</p>\n<h2 id=\"10-_语法\">10. 语法</h2>\n<p>语法就是编程语言的用户界面。虽然对于一门编程语言来说更重要的是语意，并且语法对于语意的影响也是有限的，但是语法决定了编程语言的可读性和明确性。同时，语法对于编程语言相关工具的编写至关重要：如果编程语言难以解析，那么自动化工具也将难以编写。<br>Go语言因此在设计阶段就为语言的明确性和相关工具的编写做了考虑，设计了一套简洁的语法。与C语言家族的其他几个成员相比，Go语言的词法更为精炼，仅25个关键字（C99为37个；C++11为84个；并且数量还在持续增加）。更为重要的是，Go语言的词法是规范的，因此也是易于解析的（应该说绝大部分是规范的；也存在一些我们本应修正却没有能够及时发现的怪异词法）。与C、Java特别是C++等语言不同，Go语言可以在没有类型信息或者符号表的情况下被解析，并且没有类型相关的上下文信息。Go语言的词法是易于推论的，降低了相关工具编写的难度。</p>\n<p>Go 语法不同于 C 的一个细节是，它的变量声明语法相较于 C 语言，更接近 Pascal 语言。声明的变量名称在类型之前，而有更多的关键词很：<br>var fn func([]int) int<br>type T struct { a, b int }</p>\n<p>相较于 C 语言<br>int (*fn)(int[]);<br>struct T { int a, b; }</p>\n<p>无论是对人还是对计算机，通过关键词进行变量声明将更容易被识别。而通过类型语法而非 C 的表达式语法对词法分析有一个显著的影响：它增加了语法，但消除了歧义。不过，还有一个：你可以丢掉 var 关键词，而只在表达式用使用变量的类型。两种变量声明是等价的;只是第二个更简短且共通用:<br>var buf *bytes.Buffer = bytes.NewBuffer(x) // 精确<br>buf := bytes.NewBuffer(x)                  // 衍生</p>\n<p>golang.org/s/decl-syntax 是一篇更详细讲解 Go 语言声明语句以及为什么同 C 如此不同的文章。<br>函数声明语法对于简单函数非常直接。这里有一个 Abs 函数的声明示例,它接受一个类型为 T 的变量 x，并返回一个64位浮点值：<br>func Abs(x T) float64</p>\n<p>一个方法只是一个拥有特殊参数的函数，而它的 接收器（receiver）则可以使用标准的“点”符号传递给函数。方法的声明语法将接收器放在函数名称之前的括号里。下面是一个与之前相同的函数，但它是 T 类型的一个方法：<br>func (x T) Abs() float64</p>\n<p>下面则是拥有 T 类型参数的一个变量（闭包）；Go 语言拥有第一类函数和闭包功能：<br>negAbs := func(x T) float64 { return -Abs(x) }</p>\n<p>最后，在 Go 语言中，函数可以返回多个值。通用的方法是成对返回函数结果和错误值，例如：<br>func ReadByte() (c byte, err error)</p>\n<p>c, err := ReadByte()<br>if err != nil { … }</p>\n<p>我们过会儿再说错误。</p>\n<p>Go语言缺少的一个特性是它不支持缺省参数。这是它故意简化的。经验告诉我们缺省参数太容易通过添加更多的参数来给API设计缺陷打补丁，进而导致太多使程序难以理清深圳费解的交互参数。默认参数的缺失要求更多的函数或方法被定义，因为一个函数不能控制整个接口，但这使得一个API更清晰易懂。哪些函数也都需要独立的名字， 使程序更清楚存在哪些组合，同时也鼓励更多地考虑命名—一个有关清晰性和可读性的关键因素。一个默认参数缺失的缓解因素是Go语言为可变参数函数提供易用和类型安全支持的特性。</p>\n<h2 id=\"11-_命名\">11. 命名</h2>\n<p>Go 采用了一个不常见的方法来定义标识符的可见性（可见性：包使用者(client fo a package)通过标识符使用包内成员的能力）。Go 语言中，名字自己包含了可见性的信息，而不是使用常见的private,public等关键字来标识可见性：标识符首字母的大小写决定了可见性。如果首字母是大写字母，这个标识符是exported(public); 否则是私有的。</p>\n<pre><code><span class=\"bullet\">* </span>首字母大写：名字对于包使用者可见\n<span class=\"bullet\">* </span>否则：name(或者_Name)是不可见的。\n</code></pre><p>这条规则适用于变量，类型，函数，方法，常量，域成员…等所有的东西。关于命名，需要了解的就这么多。</p>\n<p>这个设计不是个容易的决定。我们挣扎了一年多来决定怎么表示可见性。一旦我们决定了用名字的大小写来表示可见性，我们意识到这变成了Go语言最重要特性之一。毕竟，包使用者使用包时最关注名字；把可见性放在名字上而不是类型上，当用户想知道某个标示符是否是public接口，很容易就可以看出来。用了Go语言一段时间后，再用那些需要查看声明才知道可见性的语言就会觉得很麻烦。<br>很清楚，这样再一次使程序源代码清晰简洁的表达了程序员的意图。<br>另一个简洁之处是Go语言有非常紧凑的范围体系：</p>\n<pre><code><span class=\"bullet\">* </span>全局（预定义的标示符例如 int 和 string）\n<span class=\"bullet\">* </span>包（包里的所有源代码文件在同一个范围）\n<span class=\"bullet\">* </span>文件（只是在引入包时重命名，实践中不是很重要）\n<span class=\"bullet\">* </span>函数（所有函数都有，不解释）\n<span class=\"bullet\">* </span>块（不解释）\n</code></pre><p>Go语言没有命名空间，类或者其他范围。名字只来源于很少的地方，而且所有名字都遵循一样的范围体系：在源码的任何位置，一个标示符只表示一个语言对象，而独立于它的用法。（唯一的例外是语句标签(label)-break和其他类似跳转语句的目标地址；他们总是在当前函数范围有效）。<br>这样就使Go语言很清晰。例如，方法总是显式(expicit)的表明接受者(receiver)-用来访问接受者的域成员或者方法，而不是隐式(impliciti)的调用。也就是，程序员总是写<br>rcvr.Field</p>\n<p>(rcvr 代表接受者变量) 所以在词法上（lexically），每个元素总是绑定到接受者类型的某个值。 同样，包命修饰符(qualifier)总是要写在导入的名字前-要写成io.Reader而不是Reader。除了更清晰，这样Reader这种很常用的名字可以使用在任何包中。事实上，在标准库中有多个包都导出Reader，Printf这些名字，由于加上包的修饰符，这些名字引用于那个包就很清晰，不会被混淆。</p>\n<p>最终，这些规则组合起来确保了：除了顶级预先定义好的名字例如 int，每一个名字（的第一个部分-x.y中的x）总是声明在当前包。<br>简单说，名字是本地的。在C，C++，或者Java名字 y 可以指向任何事。在Go中，y（或Y）总是定义在包中， x.Y 的解释也很清晰：本地查找x，Y就在x里。<br>这些规则为可伸缩性提供了一个很重要的价值，因为他们确保为一个包增加一个公开的名字不会破坏现有的包使用者。命名规则解耦包，提供了可伸缩性，清晰性和强健性。<br>关于命名有一个更重要的方面要说一下：方法查找总是根据名字而不是方法的签名（类型） 。也就是说，一个类型里不会有两个同名的方法。给定一个方法 x.M，只有一个M在x中。这样，在只给定名字的情况下，这种方法很容易可以找到它指向那个方法。这样也使的方法调用的实现简单化了。</p>\n<h2 id=\"12-_语意\">12. 语意</h2>\n<p>Go语言的程序语句在语意上基本与C相似。它是一种拥有指针等特性的编译型的、静态类型的过程式语言。它有意的给予习惯于C语言家族的程序员一种熟悉感。对于一门新兴的编程语言来说，降低目标受众程序员的学习门槛是非常重要的；植根于C语言家族有助于确保那些掌握Java、JavaScript或是C语言的年轻程序员能更轻松的学习Go语言。<br>尽管如此，Go语言为了提高程序的健壮性，还是对C语言的语意做出了很多小改动。它们包括：</p>\n<pre><code><span class=\"bullet\">* </span>不能对指针进行算术运算\n<span class=\"bullet\">* </span>没有隐式的数值转换\n<span class=\"bullet\">* </span>数组的边界总是会被检查\n<span class=\"bullet\">* </span>没有类型别名（进行type X int的声明后，X和int是两种不同的类型而不是别名）\n<span class=\"bullet\">* </span>++和--是语句而不是表达式\n<span class=\"bullet\">* </span>赋值不是一种表达式\n<span class=\"bullet\">* </span>获取栈变量的地址是合法的（甚至是被鼓励的）\n<span class=\"bullet\">* </span>其他\n</code></pre><p>还有一些很大的改变，同传统的C 、C++ 、甚至是JAVA 的模型十分不同。它包含了对以下功能的支持：</p>\n<pre><code><span class=\"bullet\">* </span>并发\n<span class=\"bullet\">* </span>垃圾回收\n<span class=\"bullet\">* </span>接口类型\n<span class=\"bullet\">* </span>反射\n<span class=\"bullet\">* </span>类型转换\n</code></pre><p>下面的章节从软件工程的角度对 Go 语言这几个主题中的两个的讨论：并发和垃圾回收。对于语言的语义和应用的完整讨论，请参阅 golang.org 网站中的更多资源。</p>\n<h2 id=\"13-_并发\">13. 并发</h2>\n<p>运行于多核机器之上并拥有众多客户端的web服务器程序，可称为Google里最典型程序。在这样的现代计算环境中，并发很重要。这种软件用C++或Java做都不是特别好，因为它们缺在与语言级对并发支持的都不够好。<br>Go采用了一流的channel，体现为CSP的一个变种。之所以选择CSP，部分原因是因为大家对它的熟悉程度（我们中有一位同事曾使用过构建于CSP中的概念之上的前任语言），另外还因为CSP具有一种在无须对其模型做任何深入的改变就能轻易添加到过程性编程模型中的特性。也即，对于类C语言，CSP可以一种最长正交化（orthogonal）的方式添加到这种语言中，为该语言提供额外的表达能力而且还不会对该语言的其它用它施加任何约束。简言之，就是该语言的其它部分仍可保持“通常的样子”。<br>这种方法就是这样对独立执行非常规过程代码的组合。<br>结果得到的语言可以允许我们将并发同计算无缝结合都一起。假设Web服务器必须验证它的每个客户端的安全证书；在Go语言中可以很容易的使用CSP来构建这样的软件，将客户端以独立执行的过程来管理，而且还具有编译型语言的执行效率，足够应付昂贵的加密计算。</p>\n<p>总的来说，CSP对于Go和Google来说非常实用。在编写Web服务器这种Go语言的典型程序时，这个模型简直是天作之合。<br>有一条警告很重要：因为有并发，所以Go不能成为纯的内存安全（memory safe）的语言。共享内存是允许的，通过channel来传递指针也是一种习惯用法（而且效率很高）。<br>有些并发和函数式编程专家很失望，因为Go没有在并发计算的上下文中采用只写一次的方式作为值语义，比如这一点上Go和Erlang就太象。其中的原因大体上还是在于对问题域的熟悉程度和适合程度。Go的并发特性在大多数程序员所熟悉的上下文中运行得很好。Go让使得简单而安全的并发编程成为可能，但它并不阻止糟糕的编程方式。这个问题我们通过惯例来折中，训练程序员将消息传递看做拥有权限控制的一个版本。有句格言道：“不要通过共享内存来通信，要通过通信来共享内存。”<br>在对Go和并发编程都是刚刚新接触的程序员方面我们经验有限，但也表明了这是一种非常实用的方式。程序员喜欢这种支持并发为网络软件所带来的简单性，而简单性自然会带来健壮性。</p>\n<h2 id=\"14-_垃圾回收\">14. 垃圾回收</h2>\n<p>对于一门系统级的编程语言来说，垃圾回收可能会是一项非常有争议的特性，但我们还是毫不犹豫地确定了Go语言将会是一门拥有垃圾回收机制的编程语言。Go语言没有显式的内存释放操作，那些被分配的内存只能通过垃圾回收器这一唯一途径来返回内存池。<br>做出这个决定并不难，因为内存管理对于一门编程语言的实际使用方式有着深远的影响。在C和C++中，程序员们往往需要花费大量的时间和精力在内存的分配和释放上，这样的设计有助于暴露那些本可以被隐藏得很好的内存管理的细节；但反过来说，对于内存使用的过多考量又限制了程序员使用内存的方式。相比之下，垃圾回收使得接口更容易被指定。<br>此外，拥有自动化的内存管理机制对于一门并发的面向对象的编程语言来说很关键，因为一个内存块可能会在不同的并发执行单元间被来回传递，要管理这样一块内存的所有权对于程序员来说将会是一项挑战。将行为与资源的管理分离是很重要的。</p>\n<p>垃圾回收使得Go语言在使用上显得更加简单。<br>当然，垃圾回收机制会带来很大的成本：资源的消耗、回收的延迟以及复杂的实现等。尽管如此，我们相信它所带来的好处，特别是对于程序员的编程体验来说，是要大于它所带来的成本的，因为这些成本大都是加诸在编程语言的实现者身上。<br>在面向用户的系统中使用Java来进行服务器编程的经历使得一些程序员对垃圾回收顾虑重重：不可控的资源消耗、极大的延迟以及为了达到较好的性能而需要做的一大堆参数优化。Go语言则不同，语言本身的属性能够减轻以上的一些顾虑，虽然不是全部。</p>\n<p>有个关键点在于，Go为程序员提供了通过控制数据结构的格式来限制内存分配的手段。请看下面这个简单的类型定义了包含一个字节（数组）型的缓冲区：<br>type X struct {<br>    a, b, c int<br>    buf [256]byte<br>}</p>\n<p>在Java中，buffer字段需要再次进行内存分配，因为需要另一层的间接访问形式。然而在Go中，该缓冲区同包含它的struct一起分配到了一块单独的内存块中，无需间接形式。对于系统编程，这种设计可以得到更好的性能并减少回收器（collector）需要了解的项目数。要是在大规模的程序中，这么做导致的差别会非常巨大。<br>有个更加直接一点的例子，在Go中，可以非常容易和高效地提供二阶内存分配器（second-order allocator），例如，为一个由大量struct组成的大型数组分配内存，并用一个自由列表（a free list）将它们链接起来的arena分配器（an arena allocator）。在重复使用大量小型数据结构的库中，可以通过少量的提前安排，就能不产生任何垃圾还能兼顾高效和高响应度。</p>\n<p>虽然Go是一种支持内存垃圾回收的编程语言，但是资深程序员能够限制施加给回收器的压力从而提高程序的运行效率（Go的安装包中还提供了一些非常好的工具，用这些工具可以研究程序运行过程中动态内存的性能。）<br>要给程序员这样的灵活性，Go必需支持指向分配在堆中对象的指针，我们将这种指针称为内部指针。上文的例子中X.buff字段保存于struct之中，但也可以保留这个内部字段的地址。比如，可以将这个地址传递给I/O子程序。在Java以及许多类似的支持垃圾回收的语音中，不可能构造象这样的内部指针，但在Go中这么做很自然。这样设计的指针会影响可以使用的回收算法，并可能会让算法变得更难写，但经过慎重考虑，我们决定允许内部指针是必要的，因为这对程序员有好处，让大家具有降低对（可能实现起来更困难）回收器的压力的能力。到现在为止，我们的将大致相同的Go和Java程序进行对比的经验表明，使用内部指针能够大大影响arena总计大型、延迟和回收次数。<br>总的说来，Go是一门支持垃圾回收的语言，但它同时也提供给程序员一些手段，可以对回收开销进行控制。<br>垃圾回收器目前仍在积极地开发中。当前的设计方案是并行的边标示边扫描（mark-and-sweep）的回收器，未来还有机会提高其性能甚至其设计方案。（Go语言规范中并没有限定必需使用哪种特定的回收器实现方案）。尽管如此，如果程序员在使用内存时小心谨慎，当前的实现完全可以在生产环境中使用。</p>\n<h2 id=\"15-_要组合，不要继承\">15. 要组合，不要继承</h2>\n<p>Go 采用了一个不寻常的方法来支持面向对象编程，允许添加方法到任意类型，而不仅仅是class，但是并没有采用任何类似子类化的类型继承。这也就意味着没有类型体系（type hierarchy）。这是精心的设计选择。虽然类型继承已经被用来建立很多成功的软件，但是我们认为它还是被过度使用了，我们应该在这个方向上退一步。<br>Go使用接口（interface）, 接口已经在很多地方被详尽的讨论过了 (例如 research.swtch.com/interfaces ), 但是这里我还是简单的说一下。<br>在 Go 中，接口只是一组方法。例如，下面是标准库中的Hash接口的定义。<br>type Hash interface {<br>    Write(p []byte) (n int, err error)<br>    Sum(b []byte) []byte<br>    Reset()<br>    Size() int<br>    BlockSize() int<br>}</p>\n<p>实现了这组方法的所有数据类型都满足这个接口；而不需要用implements声明。即便如此，由于接口匹配在编译时静态检查，所以这样也是类型安全的。</p>\n<p>一个类型往往要满足多个接口，其方法的每一个子集满足每一个接口。例如，任何满足Hash接口的类型同时也满足Writer接口：<br>type Writer interface {<br>    Write(p []byte) (n int, err error)<br>}</p>\n<p>这种接口满足的流动性会促成一种不同的软件构造方法。但在解释这一点之前，我们应该先解释一下为什么Go中没有子类型化（subclassing）。<br>面向对象的编程提供了一种强大的见解：数据的行为可以独立于数据的表示进行泛化。这个模型在行为（方法集）是固定不变的情况下效果最好，但是，一旦你为某类型建立了一个子类型并添加了一个方法后，其行为就再也不同了。如果象Go中的静态定义的接口这样，将行为集固定下来，那么这种行为的一致性就使得可以把数据和程序一致地、正交地（orthogonally）、安全地组合到一起了。</p>\n<p>有个极端一点的例子，在Plan 9的内核中，所有的系统数据项完全都实现了同一个接口，该接口是一个由14个方法组成的文件系统API。即使在今天看来，这种一致性所允许的对象组合水平在其它系统中是很罕见的。这样的例子数不胜数。这里还有一个：一个系统可以将TCP栈导入（这是Plan 9中的术语）一个不支持TCP甚至以太网的计算机中，然后通过网络将其连接到另一台具有不同CPU架构的机器上，通过导入其/proctree，就可以允许一个本地的调试器对远程的进程进行断点调试。这类操作在Plan 9中很是平常，一点也不特殊。能够做这样的事情的能力完全来自其设计方案，无需任何特殊安排（所有的工作都是在普通的C代码中完成的）。<br>我们认为，这种系统构建中的组合风格完全被推崇类型层次结构设计的语言所忽略了。类型层次结构造成非常脆弱的代码。层次结构必需在早期进行设计，通常会是程序设计的第一步，而一旦写出程序后，早期的决策就很难进行改变了。所以，类型层次结构这种模型会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。</p>\n<p>因此，通过使用简单到通常只有一个方法的接口来定义一些很细小的行为，将这些接口作为组件间清晰易懂的边界， Go鼓励使用组合而不是继承，<br>上文中提到过Writer接口，它定义于io包中。任何具有相同签名（signature）的Write方法的类型都可以很好的同下面这个与之互补的Reader接口共存：<br>type Reader interface {<br>    Read(p []byte) (n int, err error)<br>}</p>\n<p>这两个互补的方法可以拿来进行具有多种不同行为的、类型安全的连接（chaining），比如，一般性的Unix管道。文件、缓冲区、加密程序、压缩程序、图像编码程序等等都能够连接到一起。与C中的FILE*不同，Fprintf格式化I/O子程序带有anio.Writer。格式化输出程序并不了解它要输出到哪里；可能是输出给了图像编码程序，该程序接着输出给了压缩程序，该程序再接着输出给了加密程序，最后加密程序输出到了网络连接之中。</p>\n<p>接口组合是一种不同的编程风格，已经熟悉了类型层次结构的人需要调整其思维方式才能做得好，但调整思维所得到的是类型层次结构中难以获得的具有高度适应性的设计方案。<br>还要注意，消除了类型层次结构也就消除了一种形式的依赖层次结构。接口满足式的设计使得程序无需预先确定的合约就能实现有机增长，而且这种增长是线性的；对一个接口进行更改影响的只有直接使用该接口的类型；不存在需要更改的子树。 没有implements声明会让有些人感觉不安但这么做可以让程序以自然、优雅、安全的方式进行发展。<br>Go的接口对程序设计有一个主要的影响。我们已经看到的一个地方就是使用具有接口参数的函数。这些不是方法而是函数。几个例子就应该能说明它们的威力。ReadAll返回一段字节（数组），其中包含的是能够从anio.Reader中读出来的所有数据：<br>func ReadAll(r io.Reader) ([]byte, error)</p>\n<p>封装器 —— 指的是以接口为参数并且其返回结果也是一个接口的函数，用的也很广泛。这里有几个原型。LoggingReader将每次的Read调用记录到传人的参数r这个Reader中。LimitingReader在读到n字节后便停止读取操作。ErrorInjector通过模拟I/O错误用以辅助完成测试工作。还有更多的例子。<br>func LoggingReader(r io.Reader) io.Reader<br>func LimitingReader(r io.Reader, n int64) io.Reader<br>func ErrorInjector(r io.Reader) io.Reader</p>\n<p>这种设计方法同层次型的、子类型继承方法完全不同。它们更加松散（甚至是临时性的），属于有机式的、解耦式的、独立式的，因而具有强大的伸缩性。</p>\n<h2 id=\"16-_错误\">16. 错误</h2>\n<p>Go不具有传统意义上的异常机制，也就是说，Go里没有同错误处理相关的控制结构。(Go的确为类似被零除这样的异常情况的提供了处理机制。 有一对叫做panic和recover的内建函数，用来让程序员处理这些情况。然而，这些函数是故意弄的不好用因而也很少使用它们，而且也不像Java库中使用异常那样，并没有将它们集成到库中。）<br>Go语言中错误处理的一个关键特性是一个预先定义为error的接口类型，它具有一个返回一个字符串读到Error方法，表示了一个错误值。：<br>type error interface {<br>    Error() string<br>}</p>\n<p>Go的库使用error类型的数据返回对错误的描述。结合函数具有返回多个数值的能力， 在返回计算结果的同时返回可能出现的错误值很容易实现。比如，Go中同C里的对应的getchar不会在EOF处返回一个超范围的值，也不会抛出异常；它只是返回在返回读到的字符的同时返回一个error值，以error的值为nil表示读取成功。以下所示为带缓冲区的I/O包中bufio.Reader类型的ReadByte方法的签名：</p>\n<p>func (b *Reader) ReadByte() (c byte, err error)</p>\n<p>这样的设计简单清晰，也非常容易理解。error仅仅是一种值，程序可以象对其它别的类型的值一样，对error值进行计算。<br>Go中不包含异常，是我们故意为之的。虽然有大量的批评者并不同意这个设计决策，但是我们相信有几个原因让我们认为这样做才能编写出更好的软件。</p>\n<p>首先，计算机程序中的错误并不是真正的异常情况。例如，无法打开一个文件是种常见的问题，无需任何的特殊语言结构，if和return完全可以胜任。</p>\n<p>f, err := os.Open(fileName)<br>if err != nil {<br>    return err<br>}</p>\n<p>再者，如果错误要使用特殊的控制结构，错误处理就会扭曲处理错误的程序的控制流（control flow）。象Java那样try-catch-finally语句结构会形成交叉重叠的多个控制流，这些控制流之间的交互方式非常复杂。虽然相比较而言，Go检查错误的方式更加繁琐，但这种显式的设计使得控制流更加直截了当 —— 从字面上的确如此。<br>毫无疑问这会使代码更长一些，但如此编码带来的清晰度和简单性可以弥补其冗长的缺点。显式地错误检查会迫使程序员在错误出现的时候对错误进行思考并进行相应的处理。异常机制只是将错误处理推卸到了调用堆栈之中，直到错过了修复问题或准确诊断错误情况的时机，这就使得程序员更容易去忽略错误而不是处理错误了。</p>\n<h2 id=\"17-_工具\">17. 工具</h2>\n<p>软件工程需要工具的支持。每种语言都要运行于同其它语言共存的环境，它还需要大量工具才能进行编译、编辑、调试、性能分析、测试已经运行。Go的语法、包管理系统、命名规则以及其它功能在设计时就考虑了要易于为这种语言编写工具以及包括词法分析器、语法分析器以及类型检测器等等在内的各种库。操作Go程序的工具非常容易编写，因此现在已经编写出了许多这样的工具，其中有些工具对软件工程来讲已经产生了一些值得关注的效果。其中最著名的是gofmt，它是Go源程序的格式化程序。该项目伊始，我们就将Go程序定位为由机器对其进行格式化， 从而消除了在程序员中具有争议的一大类问题：我要以什么样的格式写代码？我们对我们所需的所有Go程序运行Gofmt，绝大多数开源社区也用它进行代码格式化。 它是作为“提交前”的例行检查运行的，它在代码提交到代码库之前运行，以确保所有检入的Go程序都是具有相同的格式。</p>\n<p>Go fmt 往往被其使用者推崇为Go最好的特性之一，尽管它本身并属于Go语言的一个部分。 存在并使用gofmt意味着，从一开始社区里看到的Go代码就是用它进行格式化过的代码，因此Go程序具有现在已为人熟知的单一风格。同一的写法使得代码阅读起来更加容易，因而用起来速度也快。没有在格式化代码方面浪费的时间就是剩下来的时间。Gofmt也会影响伸缩性：既然所有的代码看上去格式完全相同，团队就更易于展开合作，用起别人的代码来也更容易。<br>Go fmt 还让编写我们并没有清晰地预见到的另一类工具成为可能。Gofmt的运行原理就是对源代码进行语法分析，然后根据语法树本身对代码进行格式化。这让在格式化代码之前对语法树进行更改成为可能，因此产生了一批进行自动重构的工具。这些工具编写起来很容易，因为它们直接作用于语法分析树之上，因而其语义可以非常多样化，最后产生的格式化代码也非常规范。</p>\n<p>第一个例子就是gofmt本身的a-r（重写）标志，该标志采用了一种很简单的模式匹配语言，可以用来进行表达式级的重写。例如，有一天我们引入了一段表达式右侧缺省值：该段表达式的长度。整个Go源代码树要使用该缺省值进行更新，仅限使用下面这一条命令：<br>gofmt -r ‘a[b:len(a)] -&gt; a[b:]’</p>\n<p>该变换中的一个关键点在于，因为输入和输出二者均为规范格式（canonical format），对源代码的唯一更改也是语义上的更改<br>采用与此类似但更复杂一些的处理就可以让gofmt用于在Go语言中的语句以换行而不再是分号结尾的情况下，对语法树进行相应的更新。</p>\n<p>gofix是另外一个非常重要的工具，它是语法树重写模块，而且它用Go语言本身所编写的，因而可以用来完成更加高级的重构操作。 gofix工具可以用来对直到Go 1发布为止的所有API和语言特性进行全方位修改，包括修改从map中删除数据项的语法、引入操作时间值的一个完全不同的API等等很多更新。随着这些更新一一推出，使用者可以通过运行下面这条简单的命令对他们的所有代码进行更新<br>gofix</p>\n<p>注意，这些工具允许我们即使在旧代码仍旧能够正常运行的情况下对它们进行更新。 因此，Go的代码库很容易就能随着library的更新而更新。弃用旧的API可以很快以自动化的形式实现，所以只有最新版本的API需要维护。例如，我们最近将Go的协议缓冲区实现更改为使用“getter”函数，而原本的接口中并不包含该函数。我们对Google中所有的Go代码运行了gofix命令，对所有使用了协议缓冲区的程序进行了更新，所以，现在使用中的协议缓冲区API只有一个版本。要对C++或者 Java库进行这样的全面更新，对于Google这样大的代码库来讲，几乎是不可能实现的。</p>\n<p>Go的标准库中具有语法分析包也使得编写大量其它工具成为可能。例如，用来管理程序构建的具有类似从远程代码库中获取包等功能的gotool；用来在library更新时验证API兼容性协约的文档抽取程序godoc；类似还有很多工具。<br>虽然类似这些工具很少在讨论语言设计时提到过，但是它们属于一种语言的生态系统中不可或缺的部分。事实上Go在设计时就考虑了工具的事情，这对该语言及其library以及整个社区的发展都已产生了巨大的影响。</p>\n<h2 id=\"18-_结论\">18. 结论</h2>\n<p>Go在google内部的使用正在越来越广泛。<br>很多大型的面向用户的服务都在使用它，包括youtube.comanddl.google.com（为chrome、android等提供下载服务的下载服务器），我们的golang.org也是用go搭建的。当然很多小的服务也在使用go，大部分都是使用Google App Engine上的内建Go环境。<br>还有很多公司也在使用Go，名单很长，其中有一些是很有名的：</p>\n<pre><code><span class=\"bullet\">* </span>BBC国际广播\n<span class=\"bullet\">* </span>Canonical\n<span class=\"bullet\">* </span>Heroku\n<span class=\"bullet\">* </span>诺基亚\n<span class=\"bullet\">* </span>SoundCloud \n</code></pre><p>看起来Go已经实现了它的目标。虽然一切看起来都很好，但是现在就说它已经成功还太早。到目前为止我们还需要更多的使用经验，特别是大型的项目（百万航代码级），来表明我们已经成功搭建一种可扩展的语言。 </p>\n<p>相对规模比较小，有些小问题还不太对，可能会在该语言的下一个（Go 2？）版本中得以纠正。例如，变量定义的语法形式过多，程序员容易被非nil接口中的nil值搞糊涂，还有许多library以及接口的方面的细节还可以再经过一轮的设计。<br>但是，值得注意的是，在升级到Go版本1时，gofix和gofmt给予了我们修复很多其它问题的机会。今天的Go同其设计者所设想的样子之间的距离因此而更近了一步，要是没有这些工具的支持就很难做到这一点，而这些工具也是因为该语言的设计思想才成为可能的。<br>不过，现在不是万事皆定了。我们仍在学习中（但是，该语言本身现在已经确定下来了。）<br>该语言有个最大的弱点，就是它的实现仍需进一步的工作。特别是其编译器所产生的代码以及runtime的运行效率还有需要改善的地方，它们还在继续的改善之中。现在已经有了一些进展；实际上，有些基准测试表明，同2012年早期发布的第一个Go版本1相比，现在开发版的性能已得到双倍提升。</p>\n<h2 id=\"19-_总结\">19. 总结</h2>\n<p>软件工程指导下的Go语言的设计。同绝大多数通用型编程语言相比，Go语言更多的是为了解决我们在构建大型服务器软件过程中所遇到的软件工程方面的问题而设计的。 乍看上去，这么讲可能会让人感觉Go非常无趣且工业化，但实际上，在设计过程中就着重于清晰和简洁，以及较高的可组合性，最后得到的反而会是一门使用起来效率高而且很有趣的编程语言，很多程序员都会发现，它有极强的表达力而且功能非常强大。<br>造成这种效果的因素有：</p>\n<pre><code><span class=\"bullet\">* </span>清晰的依赖关系\n<span class=\"bullet\">* </span>清晰的语法\n<span class=\"bullet\">* </span>清晰的语义\n<span class=\"bullet\">* </span>偏向组合而不是继承\n<span class=\"bullet\">* </span>编程模型（垃圾回收、并发）所代理的简单性\n<span class=\"bullet\">* </span>易于为它编写工具（Easy tooling ）(gotool、gofmt、godoc、gofix)\n</code></pre><p>如果你还没有尝试过用Go编程，我们建议你试一下。<br><a href=\"http://golang.org\" target=\"_blank\" rel=\"external\">http://golang.org</a> </p>\n","source":"_posts/golang-at-google.md","raw":"title: Go 在谷歌：以软件工程为目的的语言设计(转)\ndate: 2014-06-23 23:09:36\ntags:\n- 编程\ncategories: \n- golang\n---\n## 1. 摘要\n(本文是根据Rob Pike于2012年10月25日在Tucson, Arizona举行的SPLASH 2012大会上所做的主题演讲进行修改后所撰写的。)\n针对我们在Google公司内开发软件基础设施时遇到的一些问题，我们于2007年末构思出Go编程语言。当今的计算领域同创建如今所使用的编程语言（使用最多的有C++、Java和Python）时的环境几乎没什么关系了。由多核处理器、系统的网络化、大规模计算机集群和Web编程模型带来的编程问题都是以迂回的方式而不是迎头而上的方式解决的。此外，程序的规模也已发生了变化：现在的服务器程序由成百上千甚至成千上万的程序员共同编写，源代码也以数百万行计，而且实际上还需要每天都进行更新。更加雪上加霜的是，即使在大型编译集群之上进行一次build，所花的时间也已长达数十分钟甚至数小时。\n之所以设计开发Go，就是为了提高这种环境下的工作效率。Go语言设计时考虑的因素，除了大家较为了解的内置并发和内存垃圾自动回收这些方面之外，还包括严格的依赖管理、对随系统增大而在体系结构方面发生变化的适应性、跨组件边界的健壮性（robustness）。\n本文将详细讲解在构造一门轻量级并让人感觉愉悦的、高效的编译型编程语言时，这些问题是如何得到解决的。讲解过程中使用的例子都是来自Google公司中所遇到的现实问题。\n\n\n## 2. 简介\nGo语言开发自Google，是一门支持并发编程和内存垃圾回收的编译型静态类型语言。它是一个开源的项目：Google从公共的代码库中导入代码而不是相反。\nGo语言运行效率高，具有较强的可伸缩性(scalable)，而且使用它进行工作时的效率也很高。有些程序员发现用它编程很有意思；还有一些程序员认为它缺乏想象力甚至很烦人。在本文中我们将解释为什么这两种观点并不相互矛盾。Go是为解决Google在软件开发中遇到的问题而设计的，虽然因此而设计出的语言不会是一门在研究领域里具有突破性进展的语言，但它却是大型软件项目中软件工程方面的一个非常棒的工具。\n                                                    \n## 3. Google公司中的Go语言\n为了帮助解决Google自己的问题，Google设计了Go这门编程语言，可以说，Google有很大的问题。\n硬件的规模很大而且软件的规模也很大。软件的代码行数以百万计，服务器软件绝大多数用的是C++，还有很多用的是Java，剩下的一部分还用到了Python。成千上万的工程师在这些代码上工作，这些代码位于由所有软件组成的一棵树上的“头部”，所以每天这棵树的各个层次都会发生大量的修改动作。尽管使用了一个大型自主设计的分布式Build系统才让这种规模的开发变得可行，但这个规模还是太大 了。\n当然，所有这些软件都是运行在无数台机器之上的，但这些无数台的机器只是被看做数量并不多若干互相独立而仅通过网络互相连接的计算机集群。\n简言之，Google公司的开发规模很大，速度可能会比较慢，看上去往往也比较笨拙。但很有效果。\nGo项目的目标是要消除Google公司软件开发中的慢速和笨拙，从而让开发过程更加高效并且更加具有可伸缩性。该语言的设计者和使用者都是要为大型软件系统编写、阅读和调试以及维护代码的人。\n因此，Go语言的目的不是要在编程语言设计方面进行科研；它要能为它的设计者以及设计者的同事们改善工作环境。Go语言考虑更多的是软件工程而不是编程语言方面的科研。或者，换句话说，它是为软件工程服务而进行的语言设计。\n但是，编程语言怎么会对软件工程有所帮助呢？下文就是该问题的答案。\n\n## 4. 痛之所在\n当Go刚推出来时，有人认为它缺乏某些大家公认的现代编程语言中所特有的特性或方法论。缺了这些东西，Go语言怎么可能会有存在的价值？我们回答这个问题的答案在于，Go的确具有一些特性，而这些特性可以解决困扰大规模软件开发的一些问题。这些问题包括：\n\n\t* Build速度缓慢\n\t* 失控的依赖关系\n\t* 每个程序员使用同一门语言的不同子集\n\t* 程序难以理解（代码难以阅读，文档不全面等待）\n\t* 很多重复性的劳动\n\t* 更新的代价大\n\t* 版本偏斜（version skew）\n\t* 难以编写自动化工具\n\t* 语言交叉Build（cross-language build）产生的问题\n\n一门语言每个单个的特性都解决不了这些问题。这需要从软件工程的大局观，而在Go语言的设计中我们试图致力于解决所有这些问题。\n举个简单而独立的例子，我们来看看程序结果的表示方式。有些评论者反对Go中使用象C一样用花括号表示块结构，他们更喜欢Python或Haskell风格式，使用空格表示缩进。可是，我们无数次地碰到过以下这种由语言交叉Build造成的Build和测试失败：通过类似SWIG调用的方式，将一段Python代码嵌入到另外一种语言中，由于修改了这段代码周围的一些代码的缩进格式，从而导致Python代码也出乎意料地出问题了并且还非常难以觉察。 因此，我们的观点是，虽然空格缩进对于小规模的程序来说非常适用，但对大点的程序可不尽然，而且程序规模越大、代码库中的代码语言种类越多，空格缩进造成的问题就会越多。为了安全可靠，舍弃这点便利还是更好一点，因此Go采用了花括号表示的语句块。\n\n## 5.C和C++中的依赖\n在处理包依赖（package dependency）时会出现一些伸缩性以及其它方面的问题，这些问题可以更加实质性的说明上个小结中提出的问题。让我们先来回顾一下C和C++是如何处理包依赖的。\nANSI C第一次进行标准化是在1989年，它提倡要在标准的头文件中使用#ifndef这样的\"防护措施\"。 这个观点现已广泛采用，就是要求每个头文件都要用一个条件编译语句（clause）括起来，这样就可以将该头文件包含多次而不会导致编译错误。比如，Unix中的头文件<sys/stat.h>看上去大致是这样的：\n1/* Large copyright and licensing notice */\n2#ifndef _SYS_STAT_H_\n3#define _SYS_STAT_H_\n4/* Types and other definitions */\n5#endif\n\n此举的目的是让C的预处理器在第二次以及以后读到该文件时要完全忽略该头文件。符号_SYS_STAT_H_在文件第一次读到时进行定义，可以“防止”后继的调用。\n这么设计有一些好处，最重要的是可以让每个头文件能够安全地include它所有的依赖，即时其它的头文件也有同样的include语句也不会出问题。 如果遵循此规则，就可以通过对所有的#include语句按字母顺序进行排序，让代码看上去更整洁。\n但是，这种设计的可伸缩性非常差。\n\n在1984年，有人发现在编译Unix中ps命令的源程序ps.c时，在整个的预处理过程中，它包含了<sys/stat.h>这个头文件37次之多。尽管在这么多次的包含中有36次它的文件的内容都不会被包含进来，但绝大多数C编译器实现都会把\"打开文件并读取文件内容然后进行字符串扫描\"这串动作做37遍。这么做可真不聪明，实际上，C语言的预处理器要处理的宏具有如此复杂的语义，其势必导致这种行为。\n对软件产生的效果就是在C程序中不断的堆积#include语句。多加一些#include语句并不会导致程序出问题，而且想判断出其中哪些是再也不需要了的也很困难。删除一条#include语句然后再进行编译也不太足以判断出来，因为还可能有另外一条#include所包含的文件中本身还包含了你刚刚删除的那条#include语句。\n从技术角度讲，事情并不一定非得弄成这样。在意识到使用#ifndef这种防护措施所带来的长期问题之后，Plan 9的library的设计者采取了一种不同的、非ANSI标准的方法。Plan 9禁止在头文件中使用#include语句，并要求将所有的#include语句放到顶层的C文件中。 当然，这么做需要一些训练 —— 程序员需要一次列出所有需要的依赖，还要以正确的顺序排列 —— 但是文档可以帮忙而且实践中效果也非常好。这么做的结果是，一个C源程序文件无论需要多少依赖，在对它进行编译时，每个#include文件只会被读一次。当然，这样一来，对于任何#include语句都可以通过先拿掉然后在进行编译的方式判断出这条#include语句到底有无include的必要：当且仅当不需要该依赖时，拿掉#include后的源程序才能仍然可以通过编译。\n\nPlan 9的这种方式产生的一个最重要的结果是编译速度比以前快了很多：采用这种方式后编译过程中所需的I/O量，同采用#ifndef的库相比，显著地减少了不少。\n但在Plan 9之外，那种“防护”式的方式依然是C和C++编程实践中大家广为接受的方式。实际上，C++还恶化了该问题，因为它把这种防护措施使用到了更细的粒度之上。按照惯例，C++程序通常采用每个类或者一小组相关的类拥有一个头文件这种结构，这种分组方式要更小，比方说，同<stdio.h>相比要小。因而其依赖树更加错综复杂，它反映的不是对库的依赖而是对完整类型层次结构的依赖。而且，C++的头文件通常包含真正的代码 —— 类型、方法以及模板声明 ——不像一般的C语言头文件里面仅仅有一些简单的常量定义和函数签名。这样，C++就把更多的工作推给了编译器，这些东西编译起来要更难一些，而且每次编译时编译器都必须重复处理这些信息。当要build一个比较大型的C++二进制程序时，编译器可能需要成千上万次地处理头文件<string>以了解字符串的表示方式。（根据当时的记录，大约在1984年，Tom Cargill说道，在C++中使用C预处理器来处理依赖管理将是个长期的不利因素，这个问题应该得到解决。）\n\n在Google，Build一个单个的C++二进制文件就能够数万次地打开并读取数百个头文件中的每个头文件。在2007年，Google的build工程师们编译了一次Google里一个比较主要的C++二进制程序。该文件包含了两千个文件，如果只是将这些文件串接到一起，总大型为4.2M。将#include完全扩展完成后，就有8G的内容丢给编译器编译，也就是说，C++源代码中的每个自己都膨胀成到了2000字节。 还有一个数据是，在2003年Google的Build系统转变了做法，在每个目录中安排了一个Makefile，这样可以让依赖更加清晰明了并且也能好的进行管理。一般的二进制文件大小都减小了40%，就因为记录了更准确的依赖关系。即使如此，C++（或者说C引起的这个问题）的特性使得自动对依赖关系进行验证无法得以实现，直到今天我们仍然我发准确掌握Google中大型的C++二进制程序的依赖要求的具体情况。\n\n由于这种失控的依赖关系以及程序的规模非常之大，所以在单个的计算机上build出Google的服务器二进制程序就变得不太实际了，因此我们创建了一个大型分布式编译系统。该系统非常复杂（这个Build系统本身也是个大型程序）还使用了大量机器以及大量缓存，藉此在Google进行Build才算行得通了，尽管还是有些困难。 即时采用了分布式Build系统，在Google进行一次大规模的build仍需要花几十分钟的时间才能完成。前文提到的2007年那个二进制程序使用上一版本的分布式build系统花了45分钟进行build。现在所花的时间是27分钟，但是，这个程序的长度以及它的依赖关系在此期间当然也增加了。为了按比例增大build系统而在工程方面所付出的劳动刚刚比软件创建的增长速度提前了一小步。\n\n## 6. 走进 Go 语言\n当编译缓慢进行时，我们有充足的时间来思考。关于 Go 的起源有一个传说，话说正是一次长达45分钟的编译过程中，Go 的设想出现了。人们深信，为类似谷歌网络服务这样的大型程序编写一门新的语言是很有意义的，软件工程师们认为这将极大的改善谷歌程序员的生活质量。\n尽管现在的讨论更专注于依赖关系，这里依然还有很多其他需要关注的问题。这一门成功语言的主要因素是：\n\n\t* 它必须适应于大规模开发，如拥有大量依赖的大型程序，且又一个很大的程序员团队为之工作。\n\n\n\t* 它必须是熟悉的，大致为 C 风格的。谷歌的程序员在职业生涯的早期，对函数式语言，特别是 C 家族更加熟稔。要想程序员用一门新语言快速开发，新语言的语法不能过于激进。\n\n\n\t* 它必须是现代的。C、C++以及Java的某些方面，已经过于老旧，设计于多核计算机、网络和网络应用出现之前。新方法能够满足现代世界的特性，例如内置的并发。\n\n说完了背景，现在让我们从软件工程的角度谈一谈 Go 语言的设计。\n\n## 7. Go 语言的依赖处理\n既然我们谈及了很多C 和 C++ 中依赖关系处理细节，让我们看看 Go 语言是如何处理的吧。在语义和语法上，依赖处理是由语言定义的。它们是明确的、清晰的、且“能被计算的”，就是说，应该很容易被编写工具分析。\n在包封装（下节的主题）之后，每个源码文件都或有至少一个引入语句，包括 import 关键词和一个用来明确当前（只是当前）文件引入包的字符串：\nimport \"encoding/json\"\n\n使 Go 语言规整的第一步就是：睿智的依赖处理，在编译阶段，语言将未被使用的依赖视为错误（并非警告，是错误）。如果源码文件引入一个包却没有使用它，程序将无法完成编译。这将保证 Go 程序的依赖关系是明确的，没有任何多余的边际。另一方面，它可以保证编译过程不会包含无用代码，降低编译消耗的时间。\n\n第二步则是由编译器实现的，它将通过深入依赖关系确保编译效率。设想一个含有三个包的 Go 程序，其依赖关系如下：\n\n\t* A 包 引用 B 包;\n\t* B 包 引用 C 包;\n\t* A 包 不引用 C 包\n\n这就意味着，A 包对 C 包的调用是由对 B 包的调用间接实现的;也就是说，在 A 包的代码中，不存在 C 包的标识符。例如，C 包中有一个类型定义，它是 B 包中的某个为 A 包调用的结构体中的字段类型，但其本身并未被 A 包调用。具一个更实际的例子，设想一下，A 包引用了一个 格式化 I/O 包 B，B 包则引用了 C 包提供的缓冲 I/O 实现，A 包本身并没有声明缓冲 I/O。\n\n\n要编译这个程序，首先 C 被编译，被依赖的包必须在依赖于它们的包之前被编译。之后 B 包被编译;最后 A 包被编译，然后程序将被连接。\n当 A 包编译完成之后，编译器将读取 B 包的目标文件，而不是代码。此目标文件包含编译器处理 A 包代码中\nimport \"B\"\n\n语句所需的所有类型信息。这些信息也包含着 B 包在编译是所需的 C 包的信息。换句话说，当 B 包被编译时，生成的目标文件包含了所有 B 包公共接口所需的全部依赖的类型信息。\n这种设计拥有很重要的意义，当编译器处理 import 语句时，它将打开一个文件——该语句所明确的对象文件。当然，这不由的让人想起 Plan 9 C （非 ANSI C）对依赖管理方法，但不同的是，当 Go 代码文件被编译完成时，编译器将写入头文件。同 Plan 9 C 相比，这个过程将更自动化、更高效，因为：在处理 import 时读取的数据只是“输出”数据，而非程序代码。这对编译效率的影响是巨大的，而且，即便代码增长，程序依然规整如故。处理依赖树并对之编译的时间相较于 C 和 C++ 的“引入被引用文件”的模型将极大的减少。\n\n值得一提的是，这个依赖管理的通用方法并不是原始的；这些思维要追溯到1970年代的像Modula-2和Ada语言。在C语言家族里，Java就包含这一方法的元素。\n为了使编译更加高效，对象文件以导出数据作为它的首要步骤，这样编译器一旦到达文件的末尾就可以停止读取。这种依赖管理方法是为什么Go编译比C或C++编译更快的最大原因。另一个因素是Go语言把导出数据放在对象文件中；而一些语言要求程序员编写或让编译器生成包含这一信息的另一个文件。这相当于两次打开文件。在Go语言中导入一个程序包只需要打开一次文件。并且，单一文件方法意味着导出数据（或在C/C++的头文件）相对于对象文件永远不会过时。\n\n为了准确起见，我们对Google中用Go编写的某大型程序的编译进行了测算，将源代码的展开情况同前文中对C++的分析做一对比。结果发现是40倍，要比C++好50倍（同样也要比C++简单因而处理速度也快），但是这仍然比我们预期的要大。原因有两点。第一，我们发现了一个bug：Go编译器在export部分产生了大量的无用数据。第二，export数据采用了一种比较冗长的编码方式，还有改善的余地。我们正计划解决这些问题。\n然而，仅需作50分之1的事情就把原来的Build时间从分钟级的变为秒级的，将咖啡时间转化为交互式build。\nGo的依赖图还有另外一个特性，就是它不包含循环。Go语言定义了不允许其依赖图中有循环性的包含关系，编译器和链接器都会对此进行检查以确保不存在循环依赖。虽然循环依赖偶尔也有用，但它在大规模程序中会引入巨大的问题。循环依赖要求编译器同时处理大量源文件，从而会减慢增量式build的速度。更重要的是，如果允许循环依赖，我们的经验告诉我们，这种依赖最后会形成大片互相纠缠不清的源代码树，从而让树中各部分也变得很大，难以进行独立管理，最后二进制文件会膨胀，使得软件开发中的初始化、测试、重构、发布以及其它一些任务变得过于复杂。\n\n不支持循环import偶尔会让人感到苦恼，但却能让依赖树保持清晰明了，对package的清晰划分也提了个更高的要求。就象Go中其它许多设计决策一样，这会迫使程序员早早地就对一些大规模程序里的问题提前进行思考（在这种情况下，指的是package的边界），而这些问题一旦留给以后解决往往就会永远得不到满意的解决。 在标准库的设计中，大量精力花在了控制依赖关系上了。为了使用一个函数，把所需的那一小段代码拷贝过来要比拉进来一个比较大的库强（如果出现新的核心依赖的话，系统build里的一个test会报告问题）。在依赖关系方面保持良好状况要比代码重用重要。在实践中有这样一个例子，底层的网络package里有自己的整数到小数的转换程序，就是为了避免对较大的、依赖关系复杂的格式化I/O package的依赖。还有另外一个例子，字符串转换package的strconv拥有一个对‘可打印’字符的进行定义的private实现，而不是将整个大哥的Unicode字符类表格拖进去， strconv里的Unicode标准是通过package的test进行验证的。\n\n## 8. 包\nGo 的包系统设计结合了一些库、命名控件和模块的特性。\n每个 Go 的代码文件，例如“encoding/json/json.go”，都以包声明开始，如同：\npackage json\n\n“json” 就是“包名称”，一个简单的识别符号。通常包名称都比较精炼。 \n要使用包，使用 import 声明引入代码，并以 包路径 区分。“路径”的意义并未在语言中指定，而是约定为以/分割的代码包目录路径，如下：\nimport \"encoding/json\"\n\n后面用包名称（有别于路径）则用来限定引入自代码文件中包的条目。\nvar dec = json.NewDecoder(reader)\n\n这种设计非常清晰，从语法（Namevs.pkg.Name）上就能识别一个名字是否属于某个包（在此之后）。 \n在我们的示例中，包的路径是“encoding/json”而包的名称是 json。标准资源库以外，通常约定以项目或公司名作为命名控件的根：\nimport \"google/base/go/log\"\n\n\n确认包路径的唯一性非常重要，而对包名称则不必强求。包必须通过唯一的路径引入，而包名称则为引用者调用内容方式的一个约定。包名称不必唯一，可以通过引入语句重命名识别符。下面有两个自称为“package log”的包，如果要在单个源码文件中引入，需要在引入时重命名一个。\nimport \"log\"                          // Standard package\nimport googlelog \"google/base/go/log\" // Google-specific package\n\n每个公司都可能有自己的 log 包，不必要特别命名。恰恰相反：Go 的风格建议包名称保持简短和清晰，且不必担心冲突。 \n另一个例子：在 Google 代码库中有很多server 库。\n\n## 9. 远程包\nGo的包管理系统的一个重要特性是包路径，通常是一个字符串，通过识别 网站资源的URL 可以增加远程存储库。\n下面就是如何使用储存在 github 上的包。go get 命令使用 go 编译工具获取资源并安装。一旦安装完毕，就可以如同其它包一样引用它。\n$ go get github.com/4ad/doozer // Shell command to fetch package\n\nimport \"github.com/4ad/doozer\" // Doozer client's import statement\n\nvar client doozer.Conn         // Client's use of package\n\n这是值得注意的，go get 命令递归下载依赖，此特性得以实现的原因就是依赖关系的明确性。另外，由于引入路径的命名空间依赖于 URL，使得 Go 相较于其它语言，在包命名上更加分散和易于扩展。\n\n## 10. 语法\n语法就是编程语言的用户界面。虽然对于一门编程语言来说更重要的是语意，并且语法对于语意的影响也是有限的，但是语法决定了编程语言的可读性和明确性。同时，语法对于编程语言相关工具的编写至关重要：如果编程语言难以解析，那么自动化工具也将难以编写。\nGo语言因此在设计阶段就为语言的明确性和相关工具的编写做了考虑，设计了一套简洁的语法。与C语言家族的其他几个成员相比，Go语言的词法更为精炼，仅25个关键字（C99为37个；C++11为84个；并且数量还在持续增加）。更为重要的是，Go语言的词法是规范的，因此也是易于解析的（应该说绝大部分是规范的；也存在一些我们本应修正却没有能够及时发现的怪异词法）。与C、Java特别是C++等语言不同，Go语言可以在没有类型信息或者符号表的情况下被解析，并且没有类型相关的上下文信息。Go语言的词法是易于推论的，降低了相关工具编写的难度。\n\nGo 语法不同于 C 的一个细节是，它的变量声明语法相较于 C 语言，更接近 Pascal 语言。声明的变量名称在类型之前，而有更多的关键词很：\nvar fn func([]int) int\ntype T struct { a, b int }\n\n相较于 C 语言\nint (*fn)(int[]);\nstruct T { int a, b; }\n\n无论是对人还是对计算机，通过关键词进行变量声明将更容易被识别。而通过类型语法而非 C 的表达式语法对词法分析有一个显著的影响：它增加了语法，但消除了歧义。不过，还有一个：你可以丢掉 var 关键词，而只在表达式用使用变量的类型。两种变量声明是等价的;只是第二个更简短且共通用:\nvar buf *bytes.Buffer = bytes.NewBuffer(x) // 精确\nbuf := bytes.NewBuffer(x)                  // 衍生\n\ngolang.org/s/decl-syntax 是一篇更详细讲解 Go 语言声明语句以及为什么同 C 如此不同的文章。\n函数声明语法对于简单函数非常直接。这里有一个 Abs 函数的声明示例,它接受一个类型为 T 的变量 x，并返回一个64位浮点值：\nfunc Abs(x T) float64\n\n一个方法只是一个拥有特殊参数的函数，而它的 接收器（receiver）则可以使用标准的“点”符号传递给函数。方法的声明语法将接收器放在函数名称之前的括号里。下面是一个与之前相同的函数，但它是 T 类型的一个方法：\nfunc (x T) Abs() float64\n\n下面则是拥有 T 类型参数的一个变量（闭包）；Go 语言拥有第一类函数和闭包功能：\nnegAbs := func(x T) float64 { return -Abs(x) }\n\n最后，在 Go 语言中，函数可以返回多个值。通用的方法是成对返回函数结果和错误值，例如：\nfunc ReadByte() (c byte, err error)\n\nc, err := ReadByte()\nif err != nil { ... }\n\n我们过会儿再说错误。\n\nGo语言缺少的一个特性是它不支持缺省参数。这是它故意简化的。经验告诉我们缺省参数太容易通过添加更多的参数来给API设计缺陷打补丁，进而导致太多使程序难以理清深圳费解的交互参数。默认参数的缺失要求更多的函数或方法被定义，因为一个函数不能控制整个接口，但这使得一个API更清晰易懂。哪些函数也都需要独立的名字， 使程序更清楚存在哪些组合，同时也鼓励更多地考虑命名--一个有关清晰性和可读性的关键因素。一个默认参数缺失的缓解因素是Go语言为可变参数函数提供易用和类型安全支持的特性。\n\n## 11. 命名\nGo 采用了一个不常见的方法来定义标识符的可见性（可见性：包使用者(client fo a package)通过标识符使用包内成员的能力）。Go 语言中，名字自己包含了可见性的信息，而不是使用常见的private,public等关键字来标识可见性：标识符首字母的大小写决定了可见性。如果首字母是大写字母，这个标识符是exported(public); 否则是私有的。\n\n\t* 首字母大写：名字对于包使用者可见\n\t* 否则：name(或者_Name)是不可见的。\n\n这条规则适用于变量，类型，函数，方法，常量，域成员...等所有的东西。关于命名，需要了解的就这么多。\n\n\n\n这个设计不是个容易的决定。我们挣扎了一年多来决定怎么表示可见性。一旦我们决定了用名字的大小写来表示可见性，我们意识到这变成了Go语言最重要特性之一。毕竟，包使用者使用包时最关注名字；把可见性放在名字上而不是类型上，当用户想知道某个标示符是否是public接口，很容易就可以看出来。用了Go语言一段时间后，再用那些需要查看声明才知道可见性的语言就会觉得很麻烦。\n很清楚，这样再一次使程序源代码清晰简洁的表达了程序员的意图。\n另一个简洁之处是Go语言有非常紧凑的范围体系：\n\n\t* 全局（预定义的标示符例如 int 和 string）\n\t* 包（包里的所有源代码文件在同一个范围）\n\t* 文件（只是在引入包时重命名，实践中不是很重要）\n\t* 函数（所有函数都有，不解释）\n\t* 块（不解释）\n\n\nGo语言没有命名空间，类或者其他范围。名字只来源于很少的地方，而且所有名字都遵循一样的范围体系：在源码的任何位置，一个标示符只表示一个语言对象，而独立于它的用法。（唯一的例外是语句标签(label)-break和其他类似跳转语句的目标地址；他们总是在当前函数范围有效）。\n这样就使Go语言很清晰。例如，方法总是显式(expicit)的表明接受者(receiver)-用来访问接受者的域成员或者方法，而不是隐式(impliciti)的调用。也就是，程序员总是写\nrcvr.Field\n\n(rcvr 代表接受者变量) 所以在词法上（lexically），每个元素总是绑定到接受者类型的某个值。 同样，包命修饰符(qualifier)总是要写在导入的名字前-要写成io.Reader而不是Reader。除了更清晰，这样Reader这种很常用的名字可以使用在任何包中。事实上，在标准库中有多个包都导出Reader，Printf这些名字，由于加上包的修饰符，这些名字引用于那个包就很清晰，不会被混淆。\n\n最终，这些规则组合起来确保了：除了顶级预先定义好的名字例如 int，每一个名字（的第一个部分-x.y中的x）总是声明在当前包。\n简单说，名字是本地的。在C，C++，或者Java名字 y 可以指向任何事。在Go中，y（或Y）总是定义在包中， x.Y 的解释也很清晰：本地查找x，Y就在x里。\n这些规则为可伸缩性提供了一个很重要的价值，因为他们确保为一个包增加一个公开的名字不会破坏现有的包使用者。命名规则解耦包，提供了可伸缩性，清晰性和强健性。\n关于命名有一个更重要的方面要说一下：方法查找总是根据名字而不是方法的签名（类型） 。也就是说，一个类型里不会有两个同名的方法。给定一个方法 x.M，只有一个M在x中。这样，在只给定名字的情况下，这种方法很容易可以找到它指向那个方法。这样也使的方法调用的实现简单化了。\n\n## 12. 语意\nGo语言的程序语句在语意上基本与C相似。它是一种拥有指针等特性的编译型的、静态类型的过程式语言。它有意的给予习惯于C语言家族的程序员一种熟悉感。对于一门新兴的编程语言来说，降低目标受众程序员的学习门槛是非常重要的；植根于C语言家族有助于确保那些掌握Java、JavaScript或是C语言的年轻程序员能更轻松的学习Go语言。\n尽管如此，Go语言为了提高程序的健壮性，还是对C语言的语意做出了很多小改动。它们包括：\n\n\t* 不能对指针进行算术运算\n\t* 没有隐式的数值转换\n\t* 数组的边界总是会被检查\n\t* 没有类型别名（进行type X int的声明后，X和int是两种不同的类型而不是别名）\n\t* ++和--是语句而不是表达式\n\t* 赋值不是一种表达式\n\t* 获取栈变量的地址是合法的（甚至是被鼓励的）\n\t* 其他\n\n\n还有一些很大的改变，同传统的C 、C++ 、甚至是JAVA 的模型十分不同。它包含了对以下功能的支持：\n\n\t* 并发\n\t* 垃圾回收\n\t* 接口类型\n\t* 反射\n\t* 类型转换\n\n下面的章节从软件工程的角度对 Go 语言这几个主题中的两个的讨论：并发和垃圾回收。对于语言的语义和应用的完整讨论，请参阅 golang.org 网站中的更多资源。\n\n## 13. 并发\n运行于多核机器之上并拥有众多客户端的web服务器程序，可称为Google里最典型程序。在这样的现代计算环境中，并发很重要。这种软件用C++或Java做都不是特别好，因为它们缺在与语言级对并发支持的都不够好。\nGo采用了一流的channel，体现为CSP的一个变种。之所以选择CSP，部分原因是因为大家对它的熟悉程度（我们中有一位同事曾使用过构建于CSP中的概念之上的前任语言），另外还因为CSP具有一种在无须对其模型做任何深入的改变就能轻易添加到过程性编程模型中的特性。也即，对于类C语言，CSP可以一种最长正交化（orthogonal）的方式添加到这种语言中，为该语言提供额外的表达能力而且还不会对该语言的其它用它施加任何约束。简言之，就是该语言的其它部分仍可保持“通常的样子”。\n这种方法就是这样对独立执行非常规过程代码的组合。\n结果得到的语言可以允许我们将并发同计算无缝结合都一起。假设Web服务器必须验证它的每个客户端的安全证书；在Go语言中可以很容易的使用CSP来构建这样的软件，将客户端以独立执行的过程来管理，而且还具有编译型语言的执行效率，足够应付昂贵的加密计算。\n\n总的来说，CSP对于Go和Google来说非常实用。在编写Web服务器这种Go语言的典型程序时，这个模型简直是天作之合。\n有一条警告很重要：因为有并发，所以Go不能成为纯的内存安全（memory safe）的语言。共享内存是允许的，通过channel来传递指针也是一种习惯用法（而且效率很高）。\n有些并发和函数式编程专家很失望，因为Go没有在并发计算的上下文中采用只写一次的方式作为值语义，比如这一点上Go和Erlang就太象。其中的原因大体上还是在于对问题域的熟悉程度和适合程度。Go的并发特性在大多数程序员所熟悉的上下文中运行得很好。Go让使得简单而安全的并发编程成为可能，但它并不阻止糟糕的编程方式。这个问题我们通过惯例来折中，训练程序员将消息传递看做拥有权限控制的一个版本。有句格言道：“不要通过共享内存来通信，要通过通信来共享内存。”\n在对Go和并发编程都是刚刚新接触的程序员方面我们经验有限，但也表明了这是一种非常实用的方式。程序员喜欢这种支持并发为网络软件所带来的简单性，而简单性自然会带来健壮性。\n\n## 14. 垃圾回收\n对于一门系统级的编程语言来说，垃圾回收可能会是一项非常有争议的特性，但我们还是毫不犹豫地确定了Go语言将会是一门拥有垃圾回收机制的编程语言。Go语言没有显式的内存释放操作，那些被分配的内存只能通过垃圾回收器这一唯一途径来返回内存池。\n做出这个决定并不难，因为内存管理对于一门编程语言的实际使用方式有着深远的影响。在C和C++中，程序员们往往需要花费大量的时间和精力在内存的分配和释放上，这样的设计有助于暴露那些本可以被隐藏得很好的内存管理的细节；但反过来说，对于内存使用的过多考量又限制了程序员使用内存的方式。相比之下，垃圾回收使得接口更容易被指定。\n此外，拥有自动化的内存管理机制对于一门并发的面向对象的编程语言来说很关键，因为一个内存块可能会在不同的并发执行单元间被来回传递，要管理这样一块内存的所有权对于程序员来说将会是一项挑战。将行为与资源的管理分离是很重要的。\n\n垃圾回收使得Go语言在使用上显得更加简单。\n当然，垃圾回收机制会带来很大的成本：资源的消耗、回收的延迟以及复杂的实现等。尽管如此，我们相信它所带来的好处，特别是对于程序员的编程体验来说，是要大于它所带来的成本的，因为这些成本大都是加诸在编程语言的实现者身上。\n在面向用户的系统中使用Java来进行服务器编程的经历使得一些程序员对垃圾回收顾虑重重：不可控的资源消耗、极大的延迟以及为了达到较好的性能而需要做的一大堆参数优化。Go语言则不同，语言本身的属性能够减轻以上的一些顾虑，虽然不是全部。\n\n有个关键点在于，Go为程序员提供了通过控制数据结构的格式来限制内存分配的手段。请看下面这个简单的类型定义了包含一个字节（数组）型的缓冲区：\ntype X struct {\n    a, b, c int\n    buf [256]byte\n}\n\n在Java中，buffer字段需要再次进行内存分配，因为需要另一层的间接访问形式。然而在Go中，该缓冲区同包含它的struct一起分配到了一块单独的内存块中，无需间接形式。对于系统编程，这种设计可以得到更好的性能并减少回收器（collector）需要了解的项目数。要是在大规模的程序中，这么做导致的差别会非常巨大。\n有个更加直接一点的例子，在Go中，可以非常容易和高效地提供二阶内存分配器（second-order allocator），例如，为一个由大量struct组成的大型数组分配内存，并用一个自由列表（a free list）将它们链接起来的arena分配器（an arena allocator）。在重复使用大量小型数据结构的库中，可以通过少量的提前安排，就能不产生任何垃圾还能兼顾高效和高响应度。\n\n虽然Go是一种支持内存垃圾回收的编程语言，但是资深程序员能够限制施加给回收器的压力从而提高程序的运行效率（Go的安装包中还提供了一些非常好的工具，用这些工具可以研究程序运行过程中动态内存的性能。）\n要给程序员这样的灵活性，Go必需支持指向分配在堆中对象的指针，我们将这种指针称为内部指针。上文的例子中X.buff字段保存于struct之中，但也可以保留这个内部字段的地址。比如，可以将这个地址传递给I/O子程序。在Java以及许多类似的支持垃圾回收的语音中，不可能构造象这样的内部指针，但在Go中这么做很自然。这样设计的指针会影响可以使用的回收算法，并可能会让算法变得更难写，但经过慎重考虑，我们决定允许内部指针是必要的，因为这对程序员有好处，让大家具有降低对（可能实现起来更困难）回收器的压力的能力。到现在为止，我们的将大致相同的Go和Java程序进行对比的经验表明，使用内部指针能够大大影响arena总计大型、延迟和回收次数。\n总的说来，Go是一门支持垃圾回收的语言，但它同时也提供给程序员一些手段，可以对回收开销进行控制。\n垃圾回收器目前仍在积极地开发中。当前的设计方案是并行的边标示边扫描（mark-and-sweep）的回收器，未来还有机会提高其性能甚至其设计方案。（Go语言规范中并没有限定必需使用哪种特定的回收器实现方案）。尽管如此，如果程序员在使用内存时小心谨慎，当前的实现完全可以在生产环境中使用。\n\n## 15. 要组合，不要继承\nGo 采用了一个不寻常的方法来支持面向对象编程，允许添加方法到任意类型，而不仅仅是class，但是并没有采用任何类似子类化的类型继承。这也就意味着没有类型体系（type hierarchy）。这是精心的设计选择。虽然类型继承已经被用来建立很多成功的软件，但是我们认为它还是被过度使用了，我们应该在这个方向上退一步。\nGo使用接口（interface）, 接口已经在很多地方被详尽的讨论过了 (例如 research.swtch.com/interfaces ), 但是这里我还是简单的说一下。\n在 Go 中，接口只是一组方法。例如，下面是标准库中的Hash接口的定义。\ntype Hash interface {\n    Write(p []byte) (n int, err error)\n    Sum(b []byte) []byte\n    Reset()\n    Size() int\n    BlockSize() int\n}\n\n实现了这组方法的所有数据类型都满足这个接口；而不需要用implements声明。即便如此，由于接口匹配在编译时静态检查，所以这样也是类型安全的。\n\n一个类型往往要满足多个接口，其方法的每一个子集满足每一个接口。例如，任何满足Hash接口的类型同时也满足Writer接口：\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\n这种接口满足的流动性会促成一种不同的软件构造方法。但在解释这一点之前，我们应该先解释一下为什么Go中没有子类型化（subclassing）。\n面向对象的编程提供了一种强大的见解：数据的行为可以独立于数据的表示进行泛化。这个模型在行为（方法集）是固定不变的情况下效果最好，但是，一旦你为某类型建立了一个子类型并添加了一个方法后，其行为就再也不同了。如果象Go中的静态定义的接口这样，将行为集固定下来，那么这种行为的一致性就使得可以把数据和程序一致地、正交地（orthogonally）、安全地组合到一起了。\n\n有个极端一点的例子，在Plan 9的内核中，所有的系统数据项完全都实现了同一个接口，该接口是一个由14个方法组成的文件系统API。即使在今天看来，这种一致性所允许的对象组合水平在其它系统中是很罕见的。这样的例子数不胜数。这里还有一个：一个系统可以将TCP栈导入（这是Plan 9中的术语）一个不支持TCP甚至以太网的计算机中，然后通过网络将其连接到另一台具有不同CPU架构的机器上，通过导入其/proctree，就可以允许一个本地的调试器对远程的进程进行断点调试。这类操作在Plan 9中很是平常，一点也不特殊。能够做这样的事情的能力完全来自其设计方案，无需任何特殊安排（所有的工作都是在普通的C代码中完成的）。\n我们认为，这种系统构建中的组合风格完全被推崇类型层次结构设计的语言所忽略了。类型层次结构造成非常脆弱的代码。层次结构必需在早期进行设计，通常会是程序设计的第一步，而一旦写出程序后，早期的决策就很难进行改变了。所以，类型层次结构这种模型会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。\n\n\n因此，通过使用简单到通常只有一个方法的接口来定义一些很细小的行为，将这些接口作为组件间清晰易懂的边界， Go鼓励使用组合而不是继承，\n上文中提到过Writer接口，它定义于io包中。任何具有相同签名（signature）的Write方法的类型都可以很好的同下面这个与之互补的Reader接口共存：\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\n这两个互补的方法可以拿来进行具有多种不同行为的、类型安全的连接（chaining），比如，一般性的Unix管道。文件、缓冲区、加密程序、压缩程序、图像编码程序等等都能够连接到一起。与C中的FILE*不同，Fprintf格式化I/O子程序带有anio.Writer。格式化输出程序并不了解它要输出到哪里；可能是输出给了图像编码程序，该程序接着输出给了压缩程序，该程序再接着输出给了加密程序，最后加密程序输出到了网络连接之中。\n\n接口组合是一种不同的编程风格，已经熟悉了类型层次结构的人需要调整其思维方式才能做得好，但调整思维所得到的是类型层次结构中难以获得的具有高度适应性的设计方案。\n还要注意，消除了类型层次结构也就消除了一种形式的依赖层次结构。接口满足式的设计使得程序无需预先确定的合约就能实现有机增长，而且这种增长是线性的；对一个接口进行更改影响的只有直接使用该接口的类型；不存在需要更改的子树。 没有implements声明会让有些人感觉不安但这么做可以让程序以自然、优雅、安全的方式进行发展。\nGo的接口对程序设计有一个主要的影响。我们已经看到的一个地方就是使用具有接口参数的函数。这些不是方法而是函数。几个例子就应该能说明它们的威力。ReadAll返回一段字节（数组），其中包含的是能够从anio.Reader中读出来的所有数据：\nfunc ReadAll(r io.Reader) ([]byte, error)\n\n\n封装器 —— 指的是以接口为参数并且其返回结果也是一个接口的函数，用的也很广泛。这里有几个原型。LoggingReader将每次的Read调用记录到传人的参数r这个Reader中。LimitingReader在读到n字节后便停止读取操作。ErrorInjector通过模拟I/O错误用以辅助完成测试工作。还有更多的例子。\nfunc LoggingReader(r io.Reader) io.Reader\nfunc LimitingReader(r io.Reader, n int64) io.Reader\nfunc ErrorInjector(r io.Reader) io.Reader\n\n这种设计方法同层次型的、子类型继承方法完全不同。它们更加松散（甚至是临时性的），属于有机式的、解耦式的、独立式的，因而具有强大的伸缩性。\n\n## 16. 错误\nGo不具有传统意义上的异常机制，也就是说，Go里没有同错误处理相关的控制结构。(Go的确为类似被零除这样的异常情况的提供了处理机制。 有一对叫做panic和recover的内建函数，用来让程序员处理这些情况。然而，这些函数是故意弄的不好用因而也很少使用它们，而且也不像Java库中使用异常那样，并没有将它们集成到库中。）\nGo语言中错误处理的一个关键特性是一个预先定义为error的接口类型，它具有一个返回一个字符串读到Error方法，表示了一个错误值。：\ntype error interface {\n    Error() string\n}\n\n\nGo的库使用error类型的数据返回对错误的描述。结合函数具有返回多个数值的能力， 在返回计算结果的同时返回可能出现的错误值很容易实现。比如，Go中同C里的对应的getchar不会在EOF处返回一个超范围的值，也不会抛出异常；它只是返回在返回读到的字符的同时返回一个error值，以error的值为nil表示读取成功。以下所示为带缓冲区的I/O包中bufio.Reader类型的ReadByte方法的签名：\n\nfunc (b *Reader) ReadByte() (c byte, err error)\n\n这样的设计简单清晰，也非常容易理解。error仅仅是一种值，程序可以象对其它别的类型的值一样，对error值进行计算。\nGo中不包含异常，是我们故意为之的。虽然有大量的批评者并不同意这个设计决策，但是我们相信有几个原因让我们认为这样做才能编写出更好的软件。\n\n首先，计算机程序中的错误并不是真正的异常情况。例如，无法打开一个文件是种常见的问题，无需任何的特殊语言结构，if和return完全可以胜任。\n\nf, err := os.Open(fileName)\nif err != nil {\n    return err\n}\n\n再者，如果错误要使用特殊的控制结构，错误处理就会扭曲处理错误的程序的控制流（control flow）。象Java那样try-catch-finally语句结构会形成交叉重叠的多个控制流，这些控制流之间的交互方式非常复杂。虽然相比较而言，Go检查错误的方式更加繁琐，但这种显式的设计使得控制流更加直截了当 —— 从字面上的确如此。\n毫无疑问这会使代码更长一些，但如此编码带来的清晰度和简单性可以弥补其冗长的缺点。显式地错误检查会迫使程序员在错误出现的时候对错误进行思考并进行相应的处理。异常机制只是将错误处理推卸到了调用堆栈之中，直到错过了修复问题或准确诊断错误情况的时机，这就使得程序员更容易去忽略错误而不是处理错误了。\n\n## 17. 工具\n软件工程需要工具的支持。每种语言都要运行于同其它语言共存的环境，它还需要大量工具才能进行编译、编辑、调试、性能分析、测试已经运行。Go的语法、包管理系统、命名规则以及其它功能在设计时就考虑了要易于为这种语言编写工具以及包括词法分析器、语法分析器以及类型检测器等等在内的各种库。操作Go程序的工具非常容易编写，因此现在已经编写出了许多这样的工具，其中有些工具对软件工程来讲已经产生了一些值得关注的效果。其中最著名的是gofmt，它是Go源程序的格式化程序。该项目伊始，我们就将Go程序定位为由机器对其进行格式化， 从而消除了在程序员中具有争议的一大类问题：我要以什么样的格式写代码？我们对我们所需的所有Go程序运行Gofmt，绝大多数开源社区也用它进行代码格式化。 它是作为“提交前”的例行检查运行的，它在代码提交到代码库之前运行，以确保所有检入的Go程序都是具有相同的格式。\n\nGo fmt 往往被其使用者推崇为Go最好的特性之一，尽管它本身并属于Go语言的一个部分。 存在并使用gofmt意味着，从一开始社区里看到的Go代码就是用它进行格式化过的代码，因此Go程序具有现在已为人熟知的单一风格。同一的写法使得代码阅读起来更加容易，因而用起来速度也快。没有在格式化代码方面浪费的时间就是剩下来的时间。Gofmt也会影响伸缩性：既然所有的代码看上去格式完全相同，团队就更易于展开合作，用起别人的代码来也更容易。\nGo fmt 还让编写我们并没有清晰地预见到的另一类工具成为可能。Gofmt的运行原理就是对源代码进行语法分析，然后根据语法树本身对代码进行格式化。这让在格式化代码之前对语法树进行更改成为可能，因此产生了一批进行自动重构的工具。这些工具编写起来很容易，因为它们直接作用于语法分析树之上，因而其语义可以非常多样化，最后产生的格式化代码也非常规范。\n\n第一个例子就是gofmt本身的a-r（重写）标志，该标志采用了一种很简单的模式匹配语言，可以用来进行表达式级的重写。例如，有一天我们引入了一段表达式右侧缺省值：该段表达式的长度。整个Go源代码树要使用该缺省值进行更新，仅限使用下面这一条命令：\ngofmt -r 'a[b:len(a)] -> a[b:]'\n\n该变换中的一个关键点在于，因为输入和输出二者均为规范格式（canonical format），对源代码的唯一更改也是语义上的更改\n采用与此类似但更复杂一些的处理就可以让gofmt用于在Go语言中的语句以换行而不再是分号结尾的情况下，对语法树进行相应的更新。\n\ngofix是另外一个非常重要的工具，它是语法树重写模块，而且它用Go语言本身所编写的，因而可以用来完成更加高级的重构操作。 gofix工具可以用来对直到Go 1发布为止的所有API和语言特性进行全方位修改，包括修改从map中删除数据项的语法、引入操作时间值的一个完全不同的API等等很多更新。随着这些更新一一推出，使用者可以通过运行下面这条简单的命令对他们的所有代码进行更新\ngofix\n\n注意，这些工具允许我们即使在旧代码仍旧能够正常运行的情况下对它们进行更新。 因此，Go的代码库很容易就能随着library的更新而更新。弃用旧的API可以很快以自动化的形式实现，所以只有最新版本的API需要维护。例如，我们最近将Go的协议缓冲区实现更改为使用“getter”函数，而原本的接口中并不包含该函数。我们对Google中所有的Go代码运行了gofix命令，对所有使用了协议缓冲区的程序进行了更新，所以，现在使用中的协议缓冲区API只有一个版本。要对C++或者 Java库进行这样的全面更新，对于Google这样大的代码库来讲，几乎是不可能实现的。\n\nGo的标准库中具有语法分析包也使得编写大量其它工具成为可能。例如，用来管理程序构建的具有类似从远程代码库中获取包等功能的gotool；用来在library更新时验证API兼容性协约的文档抽取程序godoc；类似还有很多工具。\n虽然类似这些工具很少在讨论语言设计时提到过，但是它们属于一种语言的生态系统中不可或缺的部分。事实上Go在设计时就考虑了工具的事情，这对该语言及其library以及整个社区的发展都已产生了巨大的影响。\n\n## 18. 结论\nGo在google内部的使用正在越来越广泛。\n很多大型的面向用户的服务都在使用它，包括youtube.comanddl.google.com（为chrome、android等提供下载服务的下载服务器），我们的golang.org也是用go搭建的。当然很多小的服务也在使用go，大部分都是使用Google App Engine上的内建Go环境。\n还有很多公司也在使用Go，名单很长，其中有一些是很有名的：\n\n\t* BBC国际广播\n\t* Canonical\n\t* Heroku\n\t* 诺基亚\n\t* SoundCloud \n\n\n看起来Go已经实现了它的目标。虽然一切看起来都很好，但是现在就说它已经成功还太早。到目前为止我们还需要更多的使用经验，特别是大型的项目（百万航代码级），来表明我们已经成功搭建一种可扩展的语言。 \n\n相对规模比较小，有些小问题还不太对，可能会在该语言的下一个（Go 2？）版本中得以纠正。例如，变量定义的语法形式过多，程序员容易被非nil接口中的nil值搞糊涂，还有许多library以及接口的方面的细节还可以再经过一轮的设计。\n但是，值得注意的是，在升级到Go版本1时，gofix和gofmt给予了我们修复很多其它问题的机会。今天的Go同其设计者所设想的样子之间的距离因此而更近了一步，要是没有这些工具的支持就很难做到这一点，而这些工具也是因为该语言的设计思想才成为可能的。\n不过，现在不是万事皆定了。我们仍在学习中（但是，该语言本身现在已经确定下来了。）\n该语言有个最大的弱点，就是它的实现仍需进一步的工作。特别是其编译器所产生的代码以及runtime的运行效率还有需要改善的地方，它们还在继续的改善之中。现在已经有了一些进展；实际上，有些基准测试表明，同2012年早期发布的第一个Go版本1相比，现在开发版的性能已得到双倍提升。\n\n## 19. 总结\n软件工程指导下的Go语言的设计。同绝大多数通用型编程语言相比，Go语言更多的是为了解决我们在构建大型服务器软件过程中所遇到的软件工程方面的问题而设计的。 乍看上去，这么讲可能会让人感觉Go非常无趣且工业化，但实际上，在设计过程中就着重于清晰和简洁，以及较高的可组合性，最后得到的反而会是一门使用起来效率高而且很有趣的编程语言，很多程序员都会发现，它有极强的表达力而且功能非常强大。\n造成这种效果的因素有：\n\n\t* 清晰的依赖关系\n\t* 清晰的语法\n\t* 清晰的语义\n\t* 偏向组合而不是继承\n\t* 编程模型（垃圾回收、并发）所代理的简单性\n\t* 易于为它编写工具（Easy tooling ）(gotool、gofmt、godoc、gofix)\n\n如果你还没有尝试过用Go编程，我们建议你试一下。\nhttp://golang.org \n\n","slug":"golang-at-google","updated":1420816384000,"excerpt":"","_id":"fqoyoqempc099ak9","comments":true,"layout":"post","photos":[],"link":""},{"title":"理想主义者","date":1417967125000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>上周没有更新blog,因为看美剧去了。有点尴尬，不喜欢借口，还给自己找这种不靠谱的借口。希望以后不会，今天在回武汉的路上，除了重看老罗的《一个理想主义者的创业故事IV》外，就是在想其实我每周写一篇blog还是有很多的东西可以写的。希望自己能坚持下去。最近在看一本书《时间盈余》，和《未来是湿的》一个作者，前者讲的是自由时间的力量，后者讲的是自由组织架构的力量。两本书都不错，推荐给大家。</p>\n<p>《一个理想主义者的创业故事》系列演讲是老罗从从开始准备做手机到今天白色半T1发布，这段时间的四次演讲，听说还出版成书了《生命不惜，折腾不止》我想我肯定会买这本书，就跟买那本《我的奋斗》一样。对于这个胖子，有一种说不出的喜欢，不要说我是老残粉。他们不是我的粉丝，他们是某种信念、某种价值观、某种理想、某种人生态度的粉丝，他们来到现场，是知道从我身上能看到这些东西 —— 罗永浩</p>\n<p>坦白讲从听老罗语录到关注他做手机，到手机发布到今天，其实我还是挺希望他成功的，然后就可以去买一部他的手机。因为它会是一个好的产品。想想发觉，这两年我比较关注的人都是胖子，罗永浩，罗振宇，高晓松，是不是因为我也慢慢的是个胖子了？推荐打下看一下这个视频，也希望锤子大卖，明年我支持一下T2，上周刚入手iphone6,今年再买手机，家里的领导要崩溃了。</p>\n<p>家里的小朋友今天四个月，上周五回家了，但是小朋友感冒了，这是各种心疼，一晚上没有怎么睡觉。真的是只有自己做父母了，才能慢慢体会做爸妈的那种感觉，都希望自己能替小朋友生病。也希望小家伙快点好起来。</p>\n<p>昨天收到godaddy的邮件，好像我的域名heqq.me这个域名到期了。想了一下，然后还是决定不续费了，因为突然觉得这个域名有点太自我了，感觉不太好。现在的blog就只能是github的域名了:<a href=\"http://smilefish1987.github.io\" target=\"_blank\" rel=\"external\">http://smilefish1987.github.io</a> </p>\n<p>晚安了，大武汉 </p>\n","source":"_posts/idealist.md","raw":"title: 理想主义者\ndate: 2014-12-07 23:45:25\ntags:\n- 生活\ncategories: \n- 生活随笔\n\n---\n上周没有更新blog,因为看美剧去了。有点尴尬，不喜欢借口，还给自己找这种不靠谱的借口。希望以后不会，今天在回武汉的路上，除了重看老罗的《一个理想主义者的创业故事IV》外，就是在想其实我每周写一篇blog还是有很多的东西可以写的。希望自己能坚持下去。最近在看一本书《时间盈余》，和《未来是湿的》一个作者，前者讲的是自由时间的力量，后者讲的是自由组织架构的力量。两本书都不错，推荐给大家。\n\n《一个理想主义者的创业故事》系列演讲是老罗从从开始准备做手机到今天白色半T1发布，这段时间的四次演讲，听说还出版成书了《生命不惜，折腾不止》我想我肯定会买这本书，就跟买那本《我的奋斗》一样。对于这个胖子，有一种说不出的喜欢，不要说我是老残粉。他们不是我的粉丝，他们是某种信念、某种价值观、某种理想、某种人生态度的粉丝，他们来到现场，是知道从我身上能看到这些东西 —— 罗永浩\n\n\n坦白讲从听老罗语录到关注他做手机，到手机发布到今天，其实我还是挺希望他成功的，然后就可以去买一部他的手机。因为它会是一个好的产品。想想发觉，这两年我比较关注的人都是胖子，罗永浩，罗振宇，高晓松，是不是因为我也慢慢的是个胖子了？推荐打下看一下这个视频，也希望锤子大卖，明年我支持一下T2，上周刚入手iphone6,今年再买手机，家里的领导要崩溃了。\n\n\n家里的小朋友今天四个月，上周五回家了，但是小朋友感冒了，这是各种心疼，一晚上没有怎么睡觉。真的是只有自己做父母了，才能慢慢体会做爸妈的那种感觉，都希望自己能替小朋友生病。也希望小家伙快点好起来。\n\n\n昨天收到godaddy的邮件，好像我的域名heqq.me这个域名到期了。想了一下，然后还是决定不续费了，因为突然觉得这个域名有点太自我了，感觉不太好。现在的blog就只能是github的域名了:http://smilefish1987.github.io \n\n晚安了，大武汉 \n","slug":"idealist","updated":1417968777000,"excerpt":"","_id":"z7qlgu39hxpntm3n","comments":true,"layout":"post","photos":[],"link":""},{"title":"我不是为了输赢，我只是认真","date":1402844718000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>本来儿童节想一些东西，结果被自己耽误了。今天申请新浪开发者账号审核，没有通过，原因出乎我的意料是因为内容太少，需要专心建站。后来我自己专心看了一下自己的小站确实内容太少，所有以后要多写，争取半年后能申请通过 ^_^</p>\n<p>计划最近应该会写一个linux系列和vim系列。因为最近在学习swift可能也会写一个swift系列。至于golang就只能往后面放了。至于内容就敬请期待吧</p>\n<p>洗完早，太热了。坐下来静静的想想，发现自己都27了还什么都没有个头绪，有点整个人都不好了感觉。想者八月份辰辰就出生了，家里有个小朋友也多了一份压力。其实还是挺期待的，我再想我会不会也愣在那里说:”我这个二货居然当爹了”。为了给辰辰一份见面礼，我决定减肥到120左右，其实这个可能有点难主要我不知道自己现在是什么个吨位-_-#，早晚各种跑步，外加腹键轮希望有效，我觉得我有这个信心。</p>\n<p>开始看书了，认真的男人最美丽 ^_^ ，各位晚安 </p>\n","source":"_posts/just-do-it-better.md","raw":"title: 我不是为了输赢，我只是认真\ndate: 2014-06-15 23:05:18\ntags:\n- 生活\ncategories: \n- 生活随笔\n---\n本来儿童节想一些东西，结果被自己耽误了。今天申请新浪开发者账号审核，没有通过，原因出乎我的意料是因为内容太少，需要专心建站。后来我自己专心看了一下自己的小站确实内容太少，所有以后要多写，争取半年后能申请通过 ^_^\n\n计划最近应该会写一个linux系列和vim系列。因为最近在学习swift可能也会写一个swift系列。至于golang就只能往后面放了。至于内容就敬请期待吧\n\n洗完早，太热了。坐下来静静的想想，发现自己都27了还什么都没有个头绪，有点整个人都不好了感觉。想者八月份辰辰就出生了，家里有个小朋友也多了一份压力。其实还是挺期待的，我再想我会不会也愣在那里说:\"我这个二货居然当爹了\"。为了给辰辰一份见面礼，我决定减肥到120左右，其实这个可能有点难主要我不知道自己现在是什么个吨位-_-#，早晚各种跑步，外加腹键轮希望有效，我觉得我有这个信心。\n\n开始看书了，认真的男人最美丽 ^_^ ，各位晚安 ","slug":"just-do-it-better","updated":1420816058000,"excerpt":"","_id":"1ol6ccyqwa6d1xz1","comments":true,"layout":"post","photos":[],"link":""},{"title":"新的开始","date":1414939288000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>随着虚拟主机的涨价，以及我写blog的频率很小，导致花钱买的虚拟主机，很大程度上都是空闲的。花了2天的时间，东搞西搞把blog搬到github上了。使用hexo随便搭了一个，个人还是觉得能接受，就这样了。现在的问题是域名还没有绑上，大家可以使用下面的域名访问：<a href=\"http://smilefish1987.github.io\" target=\"_blank\" rel=\"external\">http://smilefish1987.github.io</a> ,等配好了以前的域名:<a href=\"http://www.heqq.me\" target=\"_blank\" rel=\"external\">http://www.heqq.me</a> 就可以访问。</p>\n<p>其实难的不是这个东西搭起来，难的是坚持写些东西。加油了，以后坚持一周一篇吧，然后把以前的东西版过来。</p>\n<p>其实今天下去去看了星爷的《大话西游》，虽然是20年前的经典重映，但是电影院看的人还挺多的。经典就是这样，时间越久，看得味道就越不一样。《大话西游二大圣娶妻》的两个经典桥段：</p>\n<p>1.紫霞用剑指着至尊包的那段，至尊宝的那段话：当时那把剑离我的喉咙只有0.01公分，但是在4分之1烛香之后我会让那把剑的女主人深深的爱上我！因为我决定撒一个慌，虽然本人平生撒个无数个慌。但是，我觉得这一个是最经典的。你应该这么做，我也应该死。曾经有一份真诚的爱情放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。你的剑在我的咽喉上割下去吧！不用再犹豫了！如果上天能够给我一个再来一次的机会，我会对那个女孩子说三个字：我爱你。如果非要在这份爱上加上一个期限，我希望是……一万年……</p>\n<p>2.紫霞死之前说的那段话： 我的意中人是个盖世英雄，有一天他会踩着七色的云彩来娶我， 我猜中了前头， 可是我猜不着这结局…… </p>\n<p>瞬间崩溃，我们开发的游戏《完美神话》，在卡片选择时，如果选择的是紫霞，她还会说这段话，只是没有了后面这句。 其实最后结局的时候，不谢，请叫我红领巾，也是醉了。</p>\n<p>明天周一，又要开始上班了，晚安，大武汉   </p>\n","source":"_posts/new-start.md","raw":"title: 新的开始 \ndate: 2014-11-02 22:41:28\ntags:\n- 生活\ncategories: \n- 生活随笔\n\n---\n随着虚拟主机的涨价，以及我写blog的频率很小，导致花钱买的虚拟主机，很大程度上都是空闲的。花了2天的时间，东搞西搞把blog搬到github上了。使用hexo随便搭了一个，个人还是觉得能接受，就这样了。现在的问题是域名还没有绑上，大家可以使用下面的域名访问：http://smilefish1987.github.io ,等配好了以前的域名:http://www.heqq.me 就可以访问。\n\n其实难的不是这个东西搭起来，难的是坚持写些东西。加油了，以后坚持一周一篇吧，然后把以前的东西版过来。\n\n其实今天下去去看了星爷的《大话西游》，虽然是20年前的经典重映，但是电影院看的人还挺多的。经典就是这样，时间越久，看得味道就越不一样。《大话西游二大圣娶妻》的两个经典桥段：\n\n1.紫霞用剑指着至尊包的那段，至尊宝的那段话：当时那把剑离我的喉咙只有0.01公分，但是在4分之1烛香之后我会让那把剑的女主人深深的爱上我！因为我决定撒一个慌，虽然本人平生撒个无数个慌。但是，我觉得这一个是最经典的。你应该这么做，我也应该死。曾经有一份真诚的爱情放在我面前，我没有珍惜，等我失去的时候我才后悔莫及，人世间最痛苦的事莫过于此。你的剑在我的咽喉上割下去吧！不用再犹豫了！如果上天能够给我一个再来一次的机会，我会对那个女孩子说三个字：我爱你。如果非要在这份爱上加上一个期限，我希望是……一万年……\n\n2.紫霞死之前说的那段话： 我的意中人是个盖世英雄，有一天他会踩着七色的云彩来娶我， 我猜中了前头， 可是我猜不着这结局…… \n\n瞬间崩溃，我们开发的游戏《完美神话》，在卡片选择时，如果选择的是紫霞，她还会说这段话，只是没有了后面这句。 其实最后结局的时候，不谢，请叫我红领巾，也是醉了。\n\n明天周一，又要开始上班了，晚安，大武汉   \n","slug":"new-start","updated":1420817762000,"excerpt":"","_id":"uppvcja1j75dsczo","comments":true,"layout":"post","photos":[],"link":""},{"title":"你好，2015","date":1420817908000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>不知不觉，2015年都过来快10天。今天下班后抽了一个小时的时候把之前放在pennyjob免费云主机上的一下blog移到了github上了。其实说来也惭愧，博客写的少，博客搬家到是搞了几回。最开始买了一个域名heqq.me,然后国内的云主机要备案才能用域名，就果断选择了linode。然后因为生孩子要奶粉钱，linode云主机到期后就没有续费了。微信关注了pennyjob,有一个免费云主机，就发邮件申请了一个账号，在上面跑golang写的一个blog。但是因为没有权限，管理员也很忙就一直没有配上域名，用了两三个月就把blog迁移到github上了。一年多就搞了两次迁移，希望这是最后一次，所有如果大家看到blog有些事今天提交的，然后时间确实去年的早些时候就是我迁移的东西。</p>\n<p>这段时间上班很忙，连2014年的总结和2015年的计划都要推迟写了，有点悲剧。想想自己上班也两年多，都有点后怕，混的一般的样子。哈哈，最近在玩vagrant，然后顺便写了一个vim的文章：<a href=\"https://github.com/smilefish1987/devtips/blob/master/vim/build-the-vim-dev-IDE.md\" target=\"_blank\" rel=\"external\">打造自己的Vim IDE开发环境</a>。好吧，我有点三心二意，其实以前说的通过github仓库的issue写blog也不错，还能带回复。</p>\n<p>明天估计要加班，早点睡了，晚安，大武汉</p>\n","source":"_posts/new-year-firt-worlds.md","raw":"title: 你好，2015\ndate: 2015-01-09 23:38:28\ntags:\n- 生活\ncategories: \n- 生活随笔\n---\n不知不觉，2015年都过来快10天。今天下班后抽了一个小时的时候把之前放在pennyjob免费云主机上的一下blog移到了github上了。其实说来也惭愧，博客写的少，博客搬家到是搞了几回。最开始买了一个域名heqq.me,然后国内的云主机要备案才能用域名，就果断选择了linode。然后因为生孩子要奶粉钱，linode云主机到期后就没有续费了。微信关注了pennyjob,有一个免费云主机，就发邮件申请了一个账号，在上面跑golang写的一个blog。但是因为没有权限，管理员也很忙就一直没有配上域名，用了两三个月就把blog迁移到github上了。一年多就搞了两次迁移，希望这是最后一次，所有如果大家看到blog有些事今天提交的，然后时间确实去年的早些时候就是我迁移的东西。\n\n这段时间上班很忙，连2014年的总结和2015年的计划都要推迟写了，有点悲剧。想想自己上班也两年多，都有点后怕，混的一般的样子。哈哈，最近在玩vagrant，然后顺便写了一个vim的文章：[打造自己的Vim IDE开发环境](https://github.com/smilefish1987/devtips/blob/master/vim/build-the-vim-dev-IDE.md)。好吧，我有点三心二意，其实以前说的通过github仓库的issue写blog也不错，还能带回复。\n\n明天估计要加班，早点睡了，晚安，大武汉","slug":"new-year-firt-worlds","updated":1420819252000,"excerpt":"","_id":"poch1sca6urhlcgz","comments":true,"layout":"post","photos":[],"link":""},{"title":"the book of mozilla","date":1418548339000,"tags":["vg603wvepkmtjf8f"],"categories":["k4v4w1iy6u1j422l"],"content":"<p>在看javascript的历史介绍时看到下面这段话：“玛门的双生子发生了争吵。他们的交战使世界进入了一个新的黑暗，而野兽憎恨黑暗。于是它迅速的采取行动，变得更加强大，并不断地前进和繁衍。野兽为黑暗带来了火焰与光明。 －－ mozilla之书”，兴趣使然，google了一下”the book of mozilla”,下面的内容来自维基百科：</p>\n<p>关于Mozilla之书<br>Mozilla之书并不是真有其书。不过，隠藏在Netscape和Mozilla系列网页浏览器中的内容却有着启示文学的风格，像是圣经中的启示录，令人以为真有Mozilla之书。当用户在地址栏中键入about:mozilla，根据不同的网页浏览器版本，就可以看到不同内容的Mozilla之书，所有Mozilla之书的内容都是被隐秘的，背景颜色为褐紫红，文本颜色为白色。</p>\n<p>在官方的发布软件上，可以找到共六章节Mozilla之书。而在互联网上，更可找到更多非官方的章节。这六个章节的Mozilla之书都看起来类似圣经中的内容，而下面圣经般的引用则事实上是指Netscape和Mozilla在网页浏览器开发上的重要日期。</p>\n<p>其中三个章节都提及到一只令人生畏的野兽。网景公司早年，曾用过一只名为Mozilla的吉祥物（Mozilla同时也是Netscape Navigator 1.0的开发代号）。它是一只青色的、会喷火的龙。由此可以推测Mozilla之书所提到的野兽是一种会喷火的龙，可以看作是Netscape的象征或者化身。</p>\n<p>虽然Mozilla之书部分的吸引力来自于它的神秘性，但结合网景公司和Mozilla历史上所发生的事件就可以赋予它们一些含义。除此之外，www.mozilla.org/book 上的HTML源代码更以HTML注释的方式隠藏着一些注解。这些注释是由Valerio Capello于2004年5月编写的，并由Nicholas Bebout于同年10月放上Mozilla基金会的网站。不过，Valerio Capello和Nicholas Bebout两人都不是Mozilla的核心决策者，没有证据显示这些注释是经过Mozilla基金会高级管理层的认可。</p>\n<p>Mozilla之书，12:10<br>Mozilla之书首次出现在发表于1995年的Netscape Navigator 1.1，往后的Netscape Navigator 1.x、2.x、3.x和4.x版本都可找到这段篇章。当时的预言为：</p>\n<p><strong><font color=\"red\">And the beast shall come forth surrounded by a roiling cloud of vengeance. The house of the unbelievers shall be razed and they shall be scorched to the earth. Their tags shall blink until the end of days.                         from The Book of Mozilla, 12:10 </font> </strong></p>\n<p>中译本为：</p>\n<p><strong><font color=\"red\">伴随滚滚复仇之云 ，野兽将一往无前。不信者的房子将被夷为平地，他们自己将被烧为焦土，他们的标签将会闪烁直到世界末日。 来自 Mozilla 之书，12:10 </font></strong></p>\n<p>12:10章节指的是1994年12月10日，即Netscape Navigator 1.0发布的日期。“野兽”指的是Netscape；“不信者”指的是不跟随Netscape标准的用户；“闪烁”则可以指Netscape Navigator 3或以下的源代码查看器，或由Netscape引进、有争议性的HTML blink元素。</p>\n<p>Mozilla之书，3:31<br>1998年5月10日，Jamie Zawinski将Mozilla之书改写，以说明已经将Netscape开放源代码和开始了Mozilla计划。同年10月，Netscape决定把程序代码全面改写，而这个复活节蛋亦因此丟失。在2000年2月5日，当时为Netscape工作的Ben Goodger把Mozilla之书由旧的程序代码中复制到新的程序代码。这个新的章节因此出现在Netscape 6至7.1。</p>\n<p><strong><font color=\"red\">And the beast shall be made legion. Its numbers shall be increased a thousand thousand fold. The din of a million keyboards like unto a great storm shall cover the earth, and the followers of Mammon shall tremble. from The Book of Mozilla, 3:31 (Red Letter Edition) </font></strong></p>\n<p>中译本为：</p>\n<p>野兽将会无所不在。他的数目将会暴增到上千千倍之多。无数嘈杂的键盘将会像风暴一样袭卷地球，玛门的追随者将受到撼动。来自 Mozilla 之书，3:31（红字版）</p>\n<p>3:31章节指的是1998年3月31日，即Netscape开放源代码的日期。“野兽将会无所不在”指的是网景公司想凭借开放源代码，吸引大量的开发者改善该软件（无数嘈杂的键盘将会像风暴一样袭卷地球）。</p>\n<p>而该章节提到的“玛门”在闪语族中有财富、贪欲的意思。该字可见于一般英语版的圣经中，玛门有时是贪心的恶魔的名字。因此，有人认为玛门指的是微软。微软的Internet Explorer为当时Netscape的主要竞争者。而微软除了在雄厚的资金支持外，更贪婪地以此增加它的市场占有率。“红字版”可以是指红字版（red letter edition）的圣经，或者3月31日是Mozilla计划的“红字日”（red letter day）。</p>\n<p>Mozilla之书，7:15<br>本章节由Neil Deakin所写，2003年9月发表的Mozilla Application Suite 1.5或以上、Mozilla Firefox、Camino、Mozilla Thunderbird、Epiphany 1.8.0或以上及Netscape 7.2或以上（除了部份Netscape Browser的原型）都看的到该章节：</p>\n<p><strong><font color=\"red\">And so at last the beast fell and the unbelievers rejoiced. But all was not lost, for from the ash rose a great bird. The bird gazed down upon the unbelievers and cast fire and thunder upon them. For the beast had been reborn with its strength renewed, and the followers of Mammon cowered in horror.from The Book of Mozilla, 7:15</font></strong></p>\n<p>中译本为：</p>\n<p><strong><font color=\"red\">最后野兽终于没落，不信者欢欣鼓舞。不过一切并没有失去，因为灰烬中冒出了一只巨大的鸟禽。那只鸟禽望向不信者，并将火与雷加诸于他们身上。野兽已经重生，力量更甚强大，玛门的追随者仓皇逃逸。来自 Mozilla 之书，7:15 </font></strong></p>\n<p>7:15章节指的是2003年7月15日，即美国在线（AOL）关闭旗下的Netscape浏览器部门和成立Mozilla基金会的日期。</p>\n<p>“野兽的没落”是指美国在线关闭网景部门。“灰烬中冒出了一只巨大的鸟禽”指的是Phoenix（凤凰），即现在的Mozilla Firefox。从巨鸟掷出的“火”和“雷”则分别指Mozilla Firefox和Mozilla Thunderbird——Mozilla的旗舰产品。Mozilla基金会成立后，Netscape的理念在Mozilla基金会“重生”（基金会大部分为前网景员工），基金会不再像从前一样那么依赖美国在线，力量变得“更强”。而“玛门”指的则依然是微软。</p>\n<p>Mozilla之书，8:20<br>本章节出现在2007年6月5日上市的Netscape Navigator 9.0b1之中。</p>\n<p><strong><font color=\"red\">And thus the Creator looked upon the beast reborn and saw that it was good. from The Book of Mozilla, 8:20</font></strong></p>\n<p>中译版为：</p>\n<p><strong><font color=\"red\">然后造物者看着那野兽茁壮；他看那野兽是好的。 来自 Mozilla 之书，8:20</font></strong></p>\n<p>8:20章节指的是2006年8月20日，这是第一封提及研发下一版本的Netscape Navigator的可能性的内部邮件的发送日期。造物者指的是开发者，野兽则是指Mozilla的产品。</p>\n<p>Mozilla 之书，11:9<br>本章节出现在2008年6月18日推出的Firefox 3之中。</p>\n<p><strong><font color=\"red\">Mammon slept. And the beast reborn spread over the earth and its numbers grew legion. And they proclaimed the times and sacrificed crops unto the fire, with the cunning of foxes. And they built a new world in their own image as promised by the sacred words, and spoke of the beast with their children. Mammon awoke, and lo! it was naught but a follower.from The Book of Mozilla, 11:9 (10th Edition)</font></strong></p>\n<p>中译版为：</p>\n<p><strong><font color=\"red\">玛门沉睡了。野兽重生遍布地面，而且无所不在。它们称颂时代并献出庄物直至灵巧的狐狸带来火焰。它们并依照自己的形象创造新天地，正如神圣之言所应许，尚有野兽以及孩子的话语所预言的，玛门苏醒，看！他只是个无价值的追随者。来自 Mozilla 之书，11:9 （第10版）</font></strong></p>\n<p>11:9章节指的是2004年11月9日，为Firefox 1.0官方正式发布的日子。其中“sacred words”被连到Mozilla宣言，而“spoke”被连到About Mozilla。</p>\n<p>Mozilla 之书，15:1</p>\n<p><strong><font color=\"red\">The twins of Mammon quarrelled. Their warring plunged the world into a new darkness, and the beast abhorred the darkness. So it began to move swiftly, and grew more powerful, and went forth and multiplied. And the beasts brought fire and light to the darkness. from The Book of Mozilla, 15:1</font></strong></p>\n<p>中译版为：</p>\n<p><strong><font color=\"red\">玛门的双生子发生了争吵。他们的交战使世界进入了一个新的黑暗，而野兽憎恨黑暗。于是它迅速的采取行动，变得更加强大，并不断地前进和繁衍。野兽为黑暗带来了火焰与光明。 来自 Mozilla 之书，15:1 </font></strong></p>\n<p>2013年1月23日，该章节最先出现在Mozilla主干代码库中[6]，最后出现在Firefox 21（Nightly版本）。</p>\n<p>该章节提到的玛门双子（twins of Mammon）指的是苹果公司和Google公司的移动操作系统：iOS、Android，已经垄断了移动操作系统的市场。新的黑暗（new darkness）指传统应用商店的封闭性。野兽“迅速的”采取行动指的是Firefox采取新的快速发布周期。不断地前进和繁衍（went forth and multiplied）指的是Firefox已经推出了Firefox for Android和Firefox OS面对挑战[7]。15:1章节指的是Firefox OS 1.0已进入了代码冻结阶段（2013年1月15日）。</p>\n","source":"_posts/the-book-of-mozilla.md","raw":"title: the book of mozilla\ndate: 2014-12-14 17:12:19\ntags:\n- 浏览器\ncategories: \n- 历史\n\n---\n在看javascript的历史介绍时看到下面这段话：“玛门的双生子发生了争吵。他们的交战使世界进入了一个新的黑暗，而野兽憎恨黑暗。于是它迅速的采取行动，变得更加强大，并不断地前进和繁衍。野兽为黑暗带来了火焰与光明。 －－ mozilla之书”，兴趣使然，google了一下\"the book of mozilla\",下面的内容来自维基百科：\n\n关于Mozilla之书\nMozilla之书并不是真有其书。不过，隠藏在Netscape和Mozilla系列网页浏览器中的内容却有着启示文学的风格，像是圣经中的启示录，令人以为真有Mozilla之书。当用户在地址栏中键入about:mozilla，根据不同的网页浏览器版本，就可以看到不同内容的Mozilla之书，所有Mozilla之书的内容都是被隐秘的，背景颜色为褐紫红，文本颜色为白色。\n\n在官方的发布软件上，可以找到共六章节Mozilla之书。而在互联网上，更可找到更多非官方的章节。这六个章节的Mozilla之书都看起来类似圣经中的内容，而下面圣经般的引用则事实上是指Netscape和Mozilla在网页浏览器开发上的重要日期。\n\n其中三个章节都提及到一只令人生畏的野兽。网景公司早年，曾用过一只名为Mozilla的吉祥物（Mozilla同时也是Netscape Navigator 1.0的开发代号）。它是一只青色的、会喷火的龙。由此可以推测Mozilla之书所提到的野兽是一种会喷火的龙，可以看作是Netscape的象征或者化身。\n\n虽然Mozilla之书部分的吸引力来自于它的神秘性，但结合网景公司和Mozilla历史上所发生的事件就可以赋予它们一些含义。除此之外，www.mozilla.org/book 上的HTML源代码更以HTML注释的方式隠藏着一些注解。这些注释是由Valerio Capello于2004年5月编写的，并由Nicholas Bebout于同年10月放上Mozilla基金会的网站。不过，Valerio Capello和Nicholas Bebout两人都不是Mozilla的核心决策者，没有证据显示这些注释是经过Mozilla基金会高级管理层的认可。\n\nMozilla之书，12:10\nMozilla之书首次出现在发表于1995年的Netscape Navigator 1.1，往后的Netscape Navigator 1.x、2.x、3.x和4.x版本都可找到这段篇章。当时的预言为：\n\n**<font color='red'>And the beast shall come forth surrounded by a roiling cloud of vengeance. The house of the unbelievers shall be razed and they shall be scorched to the earth. Their tags shall blink until the end of days.                         from The Book of Mozilla, 12:10 </font> **\n\n中译本为：\n\n**<font color='red'>伴随滚滚复仇之云 ，野兽将一往无前。不信者的房子将被夷为平地，他们自己将被烧为焦土，他们的标签将会闪烁直到世界末日。 来自 Mozilla 之书，12:10 </font>**\n\n12:10章节指的是1994年12月10日，即Netscape Navigator 1.0发布的日期。“野兽”指的是Netscape；“不信者”指的是不跟随Netscape标准的用户；“闪烁”则可以指Netscape Navigator 3或以下的源代码查看器，或由Netscape引进、有争议性的HTML blink元素。\n\nMozilla之书，3:31\n1998年5月10日，Jamie Zawinski将Mozilla之书改写，以说明已经将Netscape开放源代码和开始了Mozilla计划。同年10月，Netscape决定把程序代码全面改写，而这个复活节蛋亦因此丟失。在2000年2月5日，当时为Netscape工作的Ben Goodger把Mozilla之书由旧的程序代码中复制到新的程序代码。这个新的章节因此出现在Netscape 6至7.1。\n\n**<font color='red'>And the beast shall be made legion. Its numbers shall be increased a thousand thousand fold. The din of a million keyboards like unto a great storm shall cover the earth, and the followers of Mammon shall tremble. from The Book of Mozilla, 3:31 (Red Letter Edition) </font>**\n\n中译本为：\n\n</font color='red'>野兽将会无所不在。他的数目将会暴增到上千千倍之多。无数嘈杂的键盘将会像风暴一样袭卷地球，玛门的追随者将受到撼动。来自 Mozilla 之书，3:31（红字版）</font>\n\n3:31章节指的是1998年3月31日，即Netscape开放源代码的日期。“野兽将会无所不在”指的是网景公司想凭借开放源代码，吸引大量的开发者改善该软件（无数嘈杂的键盘将会像风暴一样袭卷地球）。\n\n而该章节提到的“玛门”在闪语族中有财富、贪欲的意思。该字可见于一般英语版的圣经中，玛门有时是贪心的恶魔的名字。因此，有人认为玛门指的是微软。微软的Internet Explorer为当时Netscape的主要竞争者。而微软除了在雄厚的资金支持外，更贪婪地以此增加它的市场占有率。“红字版”可以是指红字版（red letter edition）的圣经，或者3月31日是Mozilla计划的“红字日”（red letter day）。\n\nMozilla之书，7:15\n本章节由Neil Deakin所写，2003年9月发表的Mozilla Application Suite 1.5或以上、Mozilla Firefox、Camino、Mozilla Thunderbird、Epiphany 1.8.0或以上及Netscape 7.2或以上（除了部份Netscape Browser的原型）都看的到该章节：\n\n**<font color='red'>And so at last the beast fell and the unbelievers rejoiced. But all was not lost, for from the ash rose a great bird. The bird gazed down upon the unbelievers and cast fire and thunder upon them. For the beast had been reborn with its strength renewed, and the followers of Mammon cowered in horror.from The Book of Mozilla, 7:15</font>**\n\n中译本为：\n\n**<font color='red'>最后野兽终于没落，不信者欢欣鼓舞。不过一切并没有失去，因为灰烬中冒出了一只巨大的鸟禽。那只鸟禽望向不信者，并将火与雷加诸于他们身上。野兽已经重生，力量更甚强大，玛门的追随者仓皇逃逸。来自 Mozilla 之书，7:15 </font>**\n\n7:15章节指的是2003年7月15日，即美国在线（AOL）关闭旗下的Netscape浏览器部门和成立Mozilla基金会的日期。\n\n“野兽的没落”是指美国在线关闭网景部门。“灰烬中冒出了一只巨大的鸟禽”指的是Phoenix（凤凰），即现在的Mozilla Firefox。从巨鸟掷出的“火”和“雷”则分别指Mozilla Firefox和Mozilla Thunderbird——Mozilla的旗舰产品。Mozilla基金会成立后，Netscape的理念在Mozilla基金会“重生”（基金会大部分为前网景员工），基金会不再像从前一样那么依赖美国在线，力量变得“更强”。而“玛门”指的则依然是微软。\n\nMozilla之书，8:20\n本章节出现在2007年6月5日上市的Netscape Navigator 9.0b1之中。\n\n**<font color='red'>And thus the Creator looked upon the beast reborn and saw that it was good. from The Book of Mozilla, 8:20</font>**\n\n中译版为：\n\n**<font color='red'>然后造物者看着那野兽茁壮；他看那野兽是好的。 来自 Mozilla 之书，8:20</font>**\n\n8:20章节指的是2006年8月20日，这是第一封提及研发下一版本的Netscape Navigator的可能性的内部邮件的发送日期。造物者指的是开发者，野兽则是指Mozilla的产品。\n\nMozilla 之书，11:9\n本章节出现在2008年6月18日推出的Firefox 3之中。\n\n**<font color='red'>Mammon slept. And the beast reborn spread over the earth and its numbers grew legion. And they proclaimed the times and sacrificed crops unto the fire, with the cunning of foxes. And they built a new world in their own image as promised by the sacred words, and spoke of the beast with their children. Mammon awoke, and lo! it was naught but a follower.from The Book of Mozilla, 11:9 (10th Edition)</font>**\n\n\n中译版为：\n\n**<font color='red'>玛门沉睡了。野兽重生遍布地面，而且无所不在。它们称颂时代并献出庄物直至灵巧的狐狸带来火焰。它们并依照自己的形象创造新天地，正如神圣之言所应许，尚有野兽以及孩子的话语所预言的，玛门苏醒，看！他只是个无价值的追随者。来自 Mozilla 之书，11:9 （第10版）</font>**\n\n11:9章节指的是2004年11月9日，为Firefox 1.0官方正式发布的日子。其中“sacred words”被连到Mozilla宣言，而“spoke”被连到About Mozilla。\n\nMozilla 之书，15:1\n\n**<font color='red'>The twins of Mammon quarrelled. Their warring plunged the world into a new darkness, and the beast abhorred the darkness. So it began to move swiftly, and grew more powerful, and went forth and multiplied. And the beasts brought fire and light to the darkness. from The Book of Mozilla, 15:1</font>**\n\n中译版为：\n\n**<font color='red'>玛门的双生子发生了争吵。他们的交战使世界进入了一个新的黑暗，而野兽憎恨黑暗。于是它迅速的采取行动，变得更加强大，并不断地前进和繁衍。野兽为黑暗带来了火焰与光明。 来自 Mozilla 之书，15:1 </font>**\n\n2013年1月23日，该章节最先出现在Mozilla主干代码库中[6]，最后出现在Firefox 21（Nightly版本）。\n\n该章节提到的玛门双子（twins of Mammon）指的是苹果公司和Google公司的移动操作系统：iOS、Android，已经垄断了移动操作系统的市场。新的黑暗（new darkness）指传统应用商店的封闭性。野兽“迅速的”采取行动指的是Firefox采取新的快速发布周期。不断地前进和繁衍（went forth and multiplied）指的是Firefox已经推出了Firefox for Android和Firefox OS面对挑战[7]。15:1章节指的是Firefox OS 1.0已进入了代码冻结阶段（2013年1月15日）。\n","slug":"the-book-of-mozilla","updated":1418550332000,"excerpt":"","_id":"1neauukj3eyz29rm","comments":true,"layout":"post","photos":[],"link":""},{"title":"浅谈字符串编码","date":1405781672000,"tags":["twq4t4wsw1wesux9"],"categories":["5phamzh46ta4khxy"],"content":"<h4 id=\"1-_字符串的编码是个即简单又麻烦的话题，主要涉及两个不同的概念：字节(byte)和字符(character)\">1. 字符串的编码是个即简单又麻烦的话题，主要涉及两个不同的概念：字节(byte)和字符(character)</h4>\n<p><strong><em>字节</em></strong> 是计算机软件系统的最小存储单位，任何对象最终都是通过字节组合来完成存储的。<br><strong><em>字符</em></strong> 也是一种对象，它和具体的语言有关,比如在中文里，“我”是一个字符，不能生生将其当坐几个字节的拼接</p>\n<h4 id=\"2-_历史原因\">2. 历史原因</h4>\n<p>早期的计算机技术主要是处理英文等字母语言体系，ASCII编码方案足以容纳所有要表达的字符，于是每个字符占一个字节被固定下来，这也为后来造成了一定程度的误解(<strong><em>将字符和字节等同起来</em></strong>),随着计算机技术的普及，像东亚语言体系的字符数量就无法用ASCII容纳，人们只好用2个或者更多的字节来表达一个字符，于是就有了像GB2312/GBK/BIG5等种类繁多且不兼容的编码方案</p>\n<h4 id=\"3-_标准化\">3. 标准化</h4>\n<p>随着计算机技术的国际化，以往的字符编码方案已经不适应现代软件开发，ISO在参考很多现有方案的基础上统一制定了一种可以容纳世界上所有文字和符号的字符编码方案，这就是Unicode编码方案</p>\n<h4 id=\"4-_Unicode\">4. Unicode</h4>\n<p>Unicode本质上就是通过特定的算法将不同国家不同语言的字符都映射到数字上。Unicode字符集（UCS）有UCS－2，UCS－4两种标准。UCS－2最多可以表达U+FFFF个字符，而UCS－4则使用4字节编码，首位固定为0，也就是说最多可以有2^31个字符，几乎容纳了全世界所有的字符。</p>\n<h4 id=\"5-_UTF\">5. UTF</h4>\n<p>Unicode只是将字符和数字建立了映射关系，但对于计算机而言，要存储和操作任何数据，都得用字节来表示，这就涉及到不同计算机架构得大小端问题（Big Endian,Little Endian）,于是有了几种将Unicode字符数字转换成字节得方法:Unicode字符集转换格式(UCS Transformation Format) ,缩写 UTF</p>\n<h4 id=\"6-_UTF-8/16/32\">6. UTF-8/16/32</h4>\n<p><strong><em>UTF-8</em></strong> 1到4字节不等长方案，西文字符通常只用一个字节，而东亚字符(CJK)则需要三到四个字节</p>\n<p><strong><em>UTF-16</em></strong> 用2个字节无符号整数存储Unicode字符，与UCS-2对应，适合处理中文</p>\n<p><strong><em>UTF-32</em></strong> 用4个字节无符号整数存储Unicode字符，与UCS-4对应，多数时候有点浪费内存空间</p>\n<p>UTF－8具有非常良好得平台适应性和交互能力，因此已经成为很多操作系统平台的默认存储编码方案。而UTF-16因为等长，浪费空间较少，拥有更好的处理性能，包括.NET /JVM等都使用2字节的Unicode Char</p>\n<h4 id=\"7-_BOM头信息\">7. BOM头信息</h4>\n<p>按照大小端划分，UTF又有BE和LE两种格式，比如UTF-16BE/UTF-16LE等.为了让系统自动识别出BE和LE,通常在头部添加BOM信息，“FE FF” 表示BE,“FF FE”表示LE. 后面还会有一两个字符用来表示UTF-8或UTF-32.</p>\n","source":"_posts/the-text-encoding.md","raw":"title: 浅谈字符串编码\ndate: 2014-07-19 22:54:32\ntags:\n- 编程\ncategories: \n- 常识\n\n---\n#### 1. 字符串的编码是个即简单又麻烦的话题，主要涉及两个不同的概念：字节(byte)和字符(character)\n\n\n***字节*** 是计算机软件系统的最小存储单位，任何对象最终都是通过字节组合来完成存储的。\n***字符*** 也是一种对象，它和具体的语言有关,比如在中文里，“我”是一个字符，不能生生将其当坐几个字节的拼接\n\n#### 2. 历史原因\n\n早期的计算机技术主要是处理英文等字母语言体系，ASCII编码方案足以容纳所有要表达的字符，于是每个字符占一个字节被固定下来，这也为后来造成了一定程度的误解(***将字符和字节等同起来***),随着计算机技术的普及，像东亚语言体系的字符数量就无法用ASCII容纳，人们只好用2个或者更多的字节来表达一个字符，于是就有了像GB2312/GBK/BIG5等种类繁多且不兼容的编码方案\n\n#### 3. 标准化\n\n随着计算机技术的国际化，以往的字符编码方案已经不适应现代软件开发，ISO在参考很多现有方案的基础上统一制定了一种可以容纳世界上所有文字和符号的字符编码方案，这就是Unicode编码方案\n\n#### 4. Unicode\n\nUnicode本质上就是通过特定的算法将不同国家不同语言的字符都映射到数字上。Unicode字符集（UCS）有UCS－2，UCS－4两种标准。UCS－2最多可以表达U+FFFF个字符，而UCS－4则使用4字节编码，首位固定为0，也就是说最多可以有2^31个字符，几乎容纳了全世界所有的字符。\n\n#### 5. UTF\n\nUnicode只是将字符和数字建立了映射关系，但对于计算机而言，要存储和操作任何数据，都得用字节来表示，这就涉及到不同计算机架构得大小端问题（Big Endian,Little Endian）,于是有了几种将Unicode字符数字转换成字节得方法:Unicode字符集转换格式(UCS Transformation Format) ,缩写 UTF\n\n#### 6. UTF-8/16/32\n\n***UTF-8*** 1到4字节不等长方案，西文字符通常只用一个字节，而东亚字符(CJK)则需要三到四个字节\n\n***UTF-16*** 用2个字节无符号整数存储Unicode字符，与UCS-2对应，适合处理中文\n\n***UTF-32*** 用4个字节无符号整数存储Unicode字符，与UCS-4对应，多数时候有点浪费内存空间\n\nUTF－8具有非常良好得平台适应性和交互能力，因此已经成为很多操作系统平台的默认存储编码方案。而UTF-16因为等长，浪费空间较少，拥有更好的处理性能，包括.NET /JVM等都使用2字节的Unicode Char\n\n#### 7. BOM头信息\n\n按照大小端划分，UTF又有BE和LE两种格式，比如UTF-16BE/UTF-16LE等.为了让系统自动识别出BE和LE,通常在头部添加BOM信息，“FE FF” 表示BE,“FF FE”表示LE. 后面还会有一两个字符用来表示UTF-8或UTF-32.\n\n","slug":"the-text-encoding","updated":1420815503000,"excerpt":"","_id":"mn2c3ye0mz938ns7","comments":true,"layout":"post","photos":[],"link":""},{"title":"Sublime Text 快捷键","date":1406905237000,"tags":["twq4t4wsw1wesux9"],"categories":["9vyyt45ulggql03a"],"content":"<h4 id=\"1-_Ctrl+Shift+P_:_打开命令面板\">1. Ctrl+Shift+P : 打开命令面板</h4>\n<h4 id=\"2-_Ctrl+P：搜索项目中的文件\">2. Ctrl+P：搜索项目中的文件</h4>\n<h4 id=\"3-_Ctrl+G：跳转到第几行\">3. Ctrl+G：跳转到第几行</h4>\n<h4 id=\"4-_Ctrl+W：关闭当前打开文件\">4. Ctrl+W：关闭当前打开文件</h4>\n<h4 id=\"5-_Ctrl+Shift+W：关闭所有打开文件\">5. Ctrl+Shift+W：关闭所有打开文件</h4>\n<h4 id=\"6-_Ctrl+Shift+V：粘贴并格式化\">6. Ctrl+Shift+V：粘贴并格式化</h4>\n<h4 id=\"7-_Ctrl+D：选择单词，重复可增加选择下一个相同的单词\">7. Ctrl+D：选择单词，重复可增加选择下一个相同的单词</h4>\n<h4 id=\"8-_Ctrl+L：选择行，重复可依次增加选择下一行\">8. Ctrl+L：选择行，重复可依次增加选择下一行</h4>\n<h4 id=\"9-_Ctrl+Shift+L：选择多行\">9. Ctrl+Shift+L：选择多行</h4>\n<h4 id=\"10-_Ctrl+Shift+Enter：在当前行前插入新行\">10. Ctrl+Shift+Enter：在当前行前插入新行</h4>\n<h4 id=\"11-_Ctrl+X：删除当前行\">11. Ctrl+X：删除当前行</h4>\n<h4 id=\"12-_Ctrl+M：跳转到对应括号\">12. Ctrl+M：跳转到对应括号</h4>\n<h4 id=\"13-_Ctrl+U：软撤销，撤销光标位置\">13. Ctrl+U：软撤销，撤销光标位置</h4>\n<h4 id=\"14-_Ctrl+J：选择标签内容\">14. Ctrl+J：选择标签内容</h4>\n<h4 id=\"15-_Ctrl+F：查找内容\">15. Ctrl+F：查找内容</h4>\n<h4 id=\"16-_Ctrl+Shift+F：查找并替换\">16. Ctrl+Shift+F：查找并替换</h4>\n<h4 id=\"17-_Ctrl+H：替换\">17. Ctrl+H：替换</h4>\n<h4 id=\"18-_Ctrl+R：前往_method\">18. Ctrl+R：前往 method</h4>\n<h4 id=\"19-_Ctrl+N：新建窗口\">19. Ctrl+N：新建窗口</h4>\n<h4 id=\"20-_Ctrl+K+B：开关侧栏\">20. Ctrl+K+B：开关侧栏</h4>\n<h4 id=\"21-_Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身\">21. Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身</h4>\n<h4 id=\"22-_Ctrl+F2：设置/删除标记\">22. Ctrl+F2：设置/删除标记</h4>\n<h4 id=\"23-_Ctrl+/：注释当前行\">23. Ctrl+/：注释当前行</h4>\n<h4 id=\"24-_Ctrl+Shift+/：当前位置插入注释\">24. Ctrl+Shift+/：当前位置插入注释</h4>\n<h4 id=\"25-_Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的\">25. Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的</h4>\n<h4 id=\"26-_Ctrl+Shift+A：选择当前标签前后，修改标签用的\">26. Ctrl+Shift+A：选择当前标签前后，修改标签用的</h4>\n<h4 id=\"27-_F11：全屏\">27. F11：全屏</h4>\n<h4 id=\"28-_Shift+F11：全屏免打扰模式，只编辑当前文件\">28. Shift+F11：全屏免打扰模式，只编辑当前文件</h4>\n<h4 id=\"29-_Alt+F3：选择所有相同的词\">29. Alt+F3：选择所有相同的词</h4>\n<h4 id=\"30-_Alt+-：闭合标签\">30. Alt+.：闭合标签</h4>\n<h4 id=\"31-_Alt+Shift+数字：分屏显示\">31. Alt+Shift+数字：分屏显示</h4>\n<h4 id=\"32-_Alt+数字：切换打开第N个文件\">32. Alt+数字：切换打开第N个文件</h4>\n<h4 id=\"33-_Shift+右键拖动：光标多不，用来更改或插入列内容\">33. Shift+右键拖动：光标多不，用来更改或插入列内容</h4>\n<h4 id=\"34-_鼠标的前进后退键可切换Tab文件\">34. 鼠标的前进后退键可切换Tab文件</h4>\n<h4 id=\"35-_按Ctrl，依次点击或选取，可需要编辑的多个位置\">35. 按Ctrl，依次点击或选取，可需要编辑的多个位置</h4>\n<h4 id=\"36-_按Ctrl+Shift+上下键，可替换行\">36. 按Ctrl+Shift+上下键，可替换行</h4>\n<h4 id=\"sublime_编辑器，高效，快捷键也很丰富，持续更新中…-\">sublime 编辑器，高效，快捷键也很丰富，持续更新中….</h4>\n","source":"_posts/the-tips-of-sublime.md","raw":"title: Sublime Text 快捷键\ndate: 2014-08-01 23:00:37\ntags:\n- 编程\ncategories: \n- 技巧\n---\n\n#### 1. Ctrl+Shift+P : 打开命令面板\n#### 2. Ctrl+P：搜索项目中的文件\n#### 3. Ctrl+G：跳转到第几行\n#### 4. Ctrl+W：关闭当前打开文件\n#### 5. Ctrl+Shift+W：关闭所有打开文件\n#### 6. Ctrl+Shift+V：粘贴并格式化\n#### 7. Ctrl+D：选择单词，重复可增加选择下一个相同的单词\n#### 8. Ctrl+L：选择行，重复可依次增加选择下一行 \n#### 9. Ctrl+Shift+L：选择多行\n#### 10. Ctrl+Shift+Enter：在当前行前插入新行\n#### 11. Ctrl+X：删除当前行\n#### 12. Ctrl+M：跳转到对应括号\n#### 13. Ctrl+U：软撤销，撤销光标位置\n#### 14. Ctrl+J：选择标签内容\n#### 15. Ctrl+F：查找内容\n#### 16. Ctrl+Shift+F：查找并替换\n#### 17. Ctrl+H：替换\n#### 18. Ctrl+R：前往 method\n#### 19. Ctrl+N：新建窗口\n#### 20. Ctrl+K+B：开关侧栏\n#### 21. Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身\n#### 22. Ctrl+F2：设置/删除标记\n#### 23. Ctrl+/：注释当前行\n#### 24. Ctrl+Shift+/：当前位置插入注释\n#### 25. Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的\n#### 26. Ctrl+Shift+A：选择当前标签前后，修改标签用的\n#### 27. F11：全屏\n#### 28. Shift+F11：全屏免打扰模式，只编辑当前文件\n#### 29. Alt+F3：选择所有相同的词\n#### 30. Alt+.：闭合标签\n#### 31. Alt+Shift+数字：分屏显示\n#### 32. Alt+数字：切换打开第N个文件\n#### 33. Shift+右键拖动：光标多不，用来更改或插入列内容\n#### 34. 鼠标的前进后退键可切换Tab文件\n#### 35. 按Ctrl，依次点击或选取，可需要编辑的多个位置\n#### 36. 按Ctrl+Shift+上下键，可替换行\n\n#### sublime 编辑器，高效，快捷键也很丰富，持续更新中....","slug":"the-tips-of-sublime","updated":1420815755000,"excerpt":"","_id":"9f4yjutby56sdhny","comments":true,"layout":"post","photos":[],"link":""},{"title":"Linus Torvalds 的十条佳句","date":1399646679000,"tags":["twq4t4wsw1wesux9"],"categories":["81d7osy8v4rwn4jg"],"content":"<p>1.“Don’t hurry your code. Make sure it works well and is well designed. Don’t worry about timing.”<br>“不要赶代码。确保工作正常且设计合理。别太担心时间。”<br>这种快节奏的变化也允许开发者很快的完成代码合并并着手下一项工作。</p>\n<p>2.”Developers have the attention spans of slightly moronic woodland creatures.”<br>“开发者的注意力跟森林里略显愚钝的小动物们差不多。”<br>年轻的开发者很难成为维护者，因为需要一段相当长的时间来使得取得社区的信任并证明你的确会在此停留。另一方面，一旦取得了社区的信任，成为维护者也很简单：这是一项艰巨的任务，必须保持时刻关注。</p>\n<p>3.“One of the most important things for a maintainer isn’t that  he’s a super engineer. It’s that you’re responsive and people can rely  on you being there 24/7, 52 weeks a year.”<br>“对于一个维护者来说最重要的不是他技术超牛，而是具有责任心，从而使人们可以放心的认为你会全年 52 周每周 7 天每天 24 小时的坚守岗位。”<br>Linus 通常不会因为 Bug 或者技术问题而熬夜。</p>\n<p>4.“The thing with technology is if you do something stupid you can fix it.”<br>“技术上的事情，哪怕你做了蠢事，你也可以修复它。”<br>真正让 Linus 熬夜的是社区沟通和以及开发流程相关的事情。</p>\n<p>5.“When tempers flare it can be really stressful for a few  days. I have flare-ups and that works fine for me… Other people tend to  mull over things. It eats at them for weeks on end, and those issues  tend to be the painful ones.”<br>“有时候火气上来了可能会导致好几天都觉得有压力。我有时会发火，至少个人感觉不错。其他人则倾向于仔细思考。最后这些问题可能会困扰他们数周，而这通常都是些令人头疼的问题。”<br>Linus 对于劝说公司贡献内核代码或者使用开源软件持有一种进化论似的观点。它们不是看到了开源的好处，就是在经济上遇到了问题。</p>\n<p>6.“I do open source because it’s fun and it works… Companies  who work with the kernel community will waste less time and they’ll just  work better.”<br>“我从事开源是因为它有趣且可行。和内核社区合作的公司将浪费更少的时间并取得更佳的结果。”</p>\n<p>7.“If you’re a company that thinks your tiny change to the  kernel is what gives you a competitive edge, you’ll probably be facing  economic problems. You’d be much better off worrying about making the  best damn hardware for the lowest price.”<br>“如果你的公司认为对内核的微小改善可以带来具有竞争力的优势，你的公司恐怕正在面临经济问题。你最好去想想怎么样以最低的价格提供最好的硬件。”<br>Linus 对于当前桌面 Linux 的发展有句话要说：</p>\n<p>8.“I started Linux because I wanted to see it on the desktop…  I wish people would work together better … and make a really nice  login screen.”<br>“我开始设计 Linux 的时候就是想看到他能运行在桌面上。我希望人们能更好的合作，及设计一个真正好看的登录界面。”<br>他认为 Valve 的 Steam for Linux 对于桌面 Linux 来说是个绝佳的机会，可以为 Linux 发行版构建有利于推广的游戏平台标准。</p>\n<p>9.“It’s the best model for standardization. Standards should  not be people sitting in a smoky room… and writing papers. It’s being  successful enough to drive the market.”<br>“这是标准化的最好模式。标准不应该是人们坐在烟雾缭绕的房间里写草案。它应该是足够成功从而能推动市场。”<br>在多元化方面，Linus 希望内核社区能有更多女性的参与，也希望看到能有来自更多地区的贡献者。</p>\n<p>10.“We have very few women. But I’m not very worried. We used to  have this discussion about not having enough Japanese developers. We  can solve this but it will take time.”<br>“我们只有很少的女性开发者。但是我并不太担心这个。我们曾经开会讨论过日本开发者偏少的问题。我们有信心解决这些问题不过这需要时间。”</p>\n","source":"_posts/the-words-of-linus.md","raw":"title : Linus Torvalds 的十条佳句\ndate : 2014-05-09 22:44:39\ntags:\n- 编程\ncategories: \n- 语录\n\n---\n1.“Don't hurry your code. Make sure it works well and is well designed. Don't worry about timing.”\n“不要赶代码。确保工作正常且设计合理。别太担心时间。”\n这种快节奏的变化也允许开发者很快的完成代码合并并着手下一项工作。\n\n2.\"Developers have the attention spans of slightly moronic woodland creatures.\"\n“开发者的注意力跟森林里略显愚钝的小动物们差不多。” \n年轻的开发者很难成为维护者，因为需要一段相当长的时间来使得取得社区的信任并证明你的确会在此停留。另一方面，一旦取得了社区的信任，成为维护者也很简单：这是一项艰巨的任务，必须保持时刻关注。\n\n3.“One of the most important things for a maintainer isn't that  he's a super engineer. It’s that you're responsive and people can rely  on you being there 24/7, 52 weeks a year.”\n“对于一个维护者来说最重要的不是他技术超牛，而是具有责任心，从而使人们可以放心的认为你会全年 52 周每周 7 天每天 24 小时的坚守岗位。”\nLinus 通常不会因为 Bug 或者技术问题而熬夜。\n\n4.“The thing with technology is if you do something stupid you can fix it.”\n“技术上的事情，哪怕你做了蠢事，你也可以修复它。”\n真正让 Linus 熬夜的是社区沟通和以及开发流程相关的事情。\n\n5.“When tempers flare it can be really stressful for a few  days. I have flare-ups and that works fine for me… Other people tend to  mull over things. It eats at them for weeks on end, and those issues  tend to be the painful ones.”\n“有时候火气上来了可能会导致好几天都觉得有压力。我有时会发火，至少个人感觉不错。其他人则倾向于仔细思考。最后这些问题可能会困扰他们数周，而这通常都是些令人头疼的问题。”\nLinus 对于劝说公司贡献内核代码或者使用开源软件持有一种进化论似的观点。它们不是看到了开源的好处，就是在经济上遇到了问题。\n\n6.“I do open source because it's fun and it works… Companies  who work with the kernel community will waste less time and they'll just  work better.”\n“我从事开源是因为它有趣且可行。和内核社区合作的公司将浪费更少的时间并取得更佳的结果。”\n\n7.“If you're a company that thinks your tiny change to the  kernel is what gives you a competitive edge, you'll probably be facing  economic problems. You'd be much better off worrying about making the  best damn hardware for the lowest price.”\n“如果你的公司认为对内核的微小改善可以带来具有竞争力的优势，你的公司恐怕正在面临经济问题。你最好去想想怎么样以最低的价格提供最好的硬件。”\nLinus 对于当前桌面 Linux 的发展有句话要说：\n\n8.“I started Linux because I wanted to see it on the desktop...  I wish people would work together better ... and make a really nice  login screen.”\n“我开始设计 Linux 的时候就是想看到他能运行在桌面上。我希望人们能更好的合作，及设计一个真正好看的登录界面。”\n他认为 Valve 的 Steam for Linux 对于桌面 Linux 来说是个绝佳的机会，可以为 Linux 发行版构建有利于推广的游戏平台标准。\n\n9.“It's the best model for standardization. Standards should  not be people sitting in a smoky room… and writing papers. It's being  successful enough to drive the market.”\n“这是标准化的最好模式。标准不应该是人们坐在烟雾缭绕的房间里写草案。它应该是足够成功从而能推动市场。”\n在多元化方面，Linus 希望内核社区能有更多女性的参与，也希望看到能有来自更多地区的贡献者。\n\n10.“We have very few women. But I'm not very worried. We used to  have this discussion about not having enough Japanese developers. We  can solve this but it will take time.”\n“我们只有很少的女性开发者。但是我并不太担心这个。我们曾经开会讨论过日本开发者偏少的问题。我们有信心解决这些问题不过这需要时间。”\n\n\n","slug":"the-words-of-linus","updated":1420817988000,"excerpt":"","_id":"vnvf5fguzcik5uqg","comments":true,"layout":"post","photos":[],"link":""},{"title":"世界互联网大会","date":1416756834000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>第一届世界互联网大会，这周在浙江乌镇进行，互联网行业的思考者和全球互联网公司大佬们都在一起畅谈互联网／移动互联网的未来。我作为互联网的从业者，虽然不能到现场去玩，但是现场的一些直播视频还是看不了不少，重点说一下两个视频：一个是马云的演讲，一个是9个大佬参加的一个高峰论坛。在优酷上马云的演讲是看的人数最多一个视频，长度40分钟左右。马云主要讲了自己创业初期都是在研究别人怎么失败，有一些错误是创业者必须要犯的，然后是处理后这些错误，加上远见，最后是朝一个方向一直努力，成功就不远了。看到出来阿里巴巴的上市和首富的光环让马云在国内媒体的曝光了提升了不少。其实没有人的成功可以复制，我们能做的就是尽量避免犯别人同样的错误。马云也说了没有中国黄页的失败就没有今天的阿里巴巴。好吧，失败是成功之母。</p>\n<p>第二个视频时间长度一个半小时，刚开始看参加论坛的人员介绍，我就有点纳闷，怎么没有邀请鹅厂的小马哥？其实看得出来主持人是挨个得问移动互联网时代，各个大佬的公司怎么看移动互联网的前进和自己公司应对的挑战。最后问了一下大佬们对移动互联网时代对用户隐私的态度。互联网时代，用户的隐私是一个各个互联网公司不太关系，但是媒体和评论家比较关系的问题。让我想起《大数据时代》书里的那个假设，如果你打算杀了你的男朋友，然后一个月前就开始计划，在不同的商店采购不同的东西，配成一种药剂让你的男朋友的喝了一段时间后慢慢的死去，当你怎么实施的那一刻，通过对你购买物品和你举动异常的大数据的分析，警察进入你的房间，把你倒好的毒药倒掉，让你没有下手，阻止了你，但是你又没有造成犯罪的事实，不能定你的罪，但是代价又比较大，就又可能修改法律，凡事电脑大数据预测你将要犯罪就给你定罪，这样子电脑就控制人了，人们没有做事情前想的是我这样子做，电脑不会预测我犯罪吧？这个视频中间也有一些有意思的对话，推荐大家看看。</p>\n<p>《学会提问》花了一个星期，发现作者的这种内容的组织形式，整体上由浅入深，然后每一章，开始提出一个问题，然后讲办法解决这个问题，最后再当你是作者时怎么样避免你的读者对你要表达的观点产生同样的问题。感谢这本批判性思维领域的圣经，我想关键还是在于实践作者的一些方法论。  </p>\n<p>晚安了，大武汉，接下来是一周的下雨天</p>\n","source":"_posts/the-world-internet-conference.md","raw":"title: 世界互联网大会\ndate: 2014-11-23 23:33:54\ntags:\n- 生活\ncategories: \n- 生活随笔\n\n---\n第一届世界互联网大会，这周在浙江乌镇进行，互联网行业的思考者和全球互联网公司大佬们都在一起畅谈互联网／移动互联网的未来。我作为互联网的从业者，虽然不能到现场去玩，但是现场的一些直播视频还是看不了不少，重点说一下两个视频：一个是马云的演讲，一个是9个大佬参加的一个高峰论坛。在优酷上马云的演讲是看的人数最多一个视频，长度40分钟左右。马云主要讲了自己创业初期都是在研究别人怎么失败，有一些错误是创业者必须要犯的，然后是处理后这些错误，加上远见，最后是朝一个方向一直努力，成功就不远了。看到出来阿里巴巴的上市和首富的光环让马云在国内媒体的曝光了提升了不少。其实没有人的成功可以复制，我们能做的就是尽量避免犯别人同样的错误。马云也说了没有中国黄页的失败就没有今天的阿里巴巴。好吧，失败是成功之母。\n\n第二个视频时间长度一个半小时，刚开始看参加论坛的人员介绍，我就有点纳闷，怎么没有邀请鹅厂的小马哥？其实看得出来主持人是挨个得问移动互联网时代，各个大佬的公司怎么看移动互联网的前进和自己公司应对的挑战。最后问了一下大佬们对移动互联网时代对用户隐私的态度。互联网时代，用户的隐私是一个各个互联网公司不太关系，但是媒体和评论家比较关系的问题。让我想起《大数据时代》书里的那个假设，如果你打算杀了你的男朋友，然后一个月前就开始计划，在不同的商店采购不同的东西，配成一种药剂让你的男朋友的喝了一段时间后慢慢的死去，当你怎么实施的那一刻，通过对你购买物品和你举动异常的大数据的分析，警察进入你的房间，把你倒好的毒药倒掉，让你没有下手，阻止了你，但是你又没有造成犯罪的事实，不能定你的罪，但是代价又比较大，就又可能修改法律，凡事电脑大数据预测你将要犯罪就给你定罪，这样子电脑就控制人了，人们没有做事情前想的是我这样子做，电脑不会预测我犯罪吧？这个视频中间也有一些有意思的对话，推荐大家看看。\n\n《学会提问》花了一个星期，发现作者的这种内容的组织形式，整体上由浅入深，然后每一章，开始提出一个问题，然后讲办法解决这个问题，最后再当你是作者时怎么样避免你的读者对你要表达的观点产生同样的问题。感谢这本批判性思维领域的圣经，我想关键还是在于实践作者的一些方法论。  \n\n晚安了，大武汉，接下来是一周的下雨天","slug":"the-world-internet-conference","updated":1416758676000,"excerpt":"","_id":"4i9vnynit18v3nzm","comments":true,"layout":"post","photos":[],"link":""},{"title":"上线的那些事","date":1415350801000,"tags":["2krmfb4w4f626chk"],"categories":["n2o51w1di78sz9iz"],"content":"<p>现在我在从武汉回郴州的高铁上，从14:27的票改到17点。外面是有点雾霾加点雾气的天气，还零星的飘点小雨滴。听说今天是立冬，加上现在的这个情况和我的心情，有点莫名的忧伤，我本应该在这个点下高铁回家抱小朋友，而我却才开始走。冬天一个没有生机的季节，又是一个等待生机的季节，好应景，不管是我，还是我所在的公司。</p>\n<p>先说一下今天的情况，本来早上买了2点多的票。在宿舍收拾东西，带到公司上班，计划上午11点游戏开新服务器，开完没事我就回家了。10点45，策划过来跟我说，需要搞一个充值双倍的活动，要在开服前搞好。你没有听错，我也没有写错，就是这个样子的。我看了以前的代码，没有说什么，赶时间些代码，我其实蛮想11点之前搞定了，我也在11点的时候把代码提交了dev。等待测试开始测试，问题来了，服已经开起来了，然后在各种不知道什么问题，有问题有答什么的过程中过了半个小时。然后我就沉默了，因为我已经放弃了，其实我心里还是想着能按时间走的，花了半个小时去找一家大药房，有中草药买。因为家里领导说了，回去要带一些东西回去。其他的都准备好了，就是小朋友做枕头的灯芯草没有。在丰哥的帮助下，1点半买到了灯芯草，在这里特别感谢一下丰哥。在回公司的路上，得知充值双倍活动今天不上了，呵呵，我还能说什么，准备拿东西走人。</p>\n<p>一阵讨论和邮件发完之后我就拿东西往车站敢，但是时间已经是15点了。我默默的走了，天下着雨，我思考着今天的事情。</p>\n<p>请问：</p>\n<blockquote>\n<ol>\n<li><p>能不能不要在开服还有几分钟的时候，添加／删除／修改已经计划要上线的功能？</p>\n</li>\n<li><p>能不能在一周前就把今天开发包含的功能开发／测试／部署成功？</p>\n</li>\n<li><p>能不能在功能开发的时候，不要一个人来一套，提出的人和验收的人不是一起的？</p>\n</li>\n</ol>\n</blockquote>\n<p>这个样子造成的问题是：开发人员和运营人员都好累，一到开服就加班，通宵什么的，关键是加班，通宵玩了，最后功能还不上，伤不伤士气？还有团队的默契和合作关系？</p>\n<p>不喜欢每次都以我们是新手，我们团队参差不齐什么的来作为借口。都搞一年了，服务器都开了七八个了，还能说我们没经验，是新手？</p>\n<p>作为开发人员，我体会最深的就是：</p>\n<blockquote>\n<ol>\n<li><p>功能的实现写多健壮和灵活都不为过，因为我们面对的是一个可能分分钟变的世界，真的，唯一不变的就是变化本身</p>\n</li>\n<li><p>重构，重构，再重构  没经过重构的代码，就是没有信心的代码</p>\n</li>\n<li><p>不要满足于现状  当你对一个业务很熟悉，你可以花30％的时间就搞定工作上的情况，请问，其他的时间被你花到哪里去了？</p>\n</li>\n</ol>\n</blockquote>\n<p>人总要学会成长，不是因为满足于现状，去挑战一下自己，年轻有什么可以。我想我在这边怎么写，都不一定会被他们看见，但是写写又何妨。</p>\n","source":"_posts/about-functions-to-production.md","raw":"title : 上线的那些事\ndate : 2014-11-07 17:00:01\ntags:\n- 生活\ncategories: \n- 生活随笔\n\n---\n现在我在从武汉回郴州的高铁上，从14:27的票改到17点。外面是有点雾霾加点雾气的天气，还零星的飘点小雨滴。听说今天是立冬，加上现在的这个情况和我的心情，有点莫名的忧伤，我本应该在这个点下高铁回家抱小朋友，而我却才开始走。冬天一个没有生机的季节，又是一个等待生机的季节，好应景，不管是我，还是我所在的公司。\n\n先说一下今天的情况，本来早上买了2点多的票。在宿舍收拾东西，带到公司上班，计划上午11点游戏开新服务器，开完没事我就回家了。10点45，策划过来跟我说，需要搞一个充值双倍的活动，要在开服前搞好。你没有听错，我也没有写错，就是这个样子的。我看了以前的代码，没有说什么，赶时间些代码，我其实蛮想11点之前搞定了，我也在11点的时候把代码提交了dev。等待测试开始测试，问题来了，服已经开起来了，然后在各种不知道什么问题，有问题有答什么的过程中过了半个小时。然后我就沉默了，因为我已经放弃了，其实我心里还是想着能按时间走的，花了半个小时去找一家大药房，有中草药买。因为家里领导说了，回去要带一些东西回去。其他的都准备好了，就是小朋友做枕头的灯芯草没有。在丰哥的帮助下，1点半买到了灯芯草，在这里特别感谢一下丰哥。在回公司的路上，得知充值双倍活动今天不上了，呵呵，我还能说什么，准备拿东西走人。\n\n一阵讨论和邮件发完之后我就拿东西往车站敢，但是时间已经是15点了。我默默的走了，天下着雨，我思考着今天的事情。\n\n请问：\n> 1. 能不能不要在开服还有几分钟的时候，添加／删除／修改已经计划要上线的功能？\n\n> 2. 能不能在一周前就把今天开发包含的功能开发／测试／部署成功？\n\n> 3. 能不能在功能开发的时候，不要一个人来一套，提出的人和验收的人不是一起的？\n\n这个样子造成的问题是：开发人员和运营人员都好累，一到开服就加班，通宵什么的，关键是加班，通宵玩了，最后功能还不上，伤不伤士气？还有团队的默契和合作关系？\n\n不喜欢每次都以我们是新手，我们团队参差不齐什么的来作为借口。都搞一年了，服务器都开了七八个了，还能说我们没经验，是新手？\n\n\n作为开发人员，我体会最深的就是：\n\n> 1. 功能的实现写多健壮和灵活都不为过，因为我们面对的是一个可能分分钟变的世界，真的，唯一不变的就是变化本身\n\n> 2. 重构，重构，再重构  没经过重构的代码，就是没有信心的代码\n\n> 3. 不要满足于现状  当你对一个业务很熟悉，你可以花30％的时间就搞定工作上的情况，请问，其他的时间被你花到哪里去了？\n\n\n人总要学会成长，不是因为满足于现状，去挑战一下自己，年轻有什么可以。我想我在这边怎么写，都不一定会被他们看见，但是写写又何妨。","slug":"about-functions-to-production","updated":1415354755000,"excerpt":"","_id":"vhh0v15cgu3bltjs","comments":true,"layout":"post","photos":[],"link":""},{"title":"学会提问","date":1416145463000,"tags":["2krmfb4w4f626chk"],"categories":["020pxy17uxp44hgo"],"content":"<p>又一年的双十一在这个星期的星期二，以571亿的交易额，妥妥的刷新着去年的数据。我想明年还会再刷新今年的数据，对我来说，唯一不同的是今年的这571亿，没有我的努力也没有我们家领导的努力。给小朋友买的披风还是11月12号买的。听到一个段子：只有长的丑的人才会安安心心的做一番事业，然后挣很多的钱，长的帅的，不是泡妞去了，就是被妞泡了。好多人估计都在想，终于找到自己穷的理由了？-_-#</p>\n<p>最近在读一本《学会提问》的书，也就是这篇文章的标题，虽然没有读完，但是我还是想摘抄一些东西：</p>\n<p>1.通往合理结论的道路往往从问题开始，并且一路都有问题相伴</p>\n<p>2.批判性思维有一套相互联系、环环相扣的关键问题的意识，同时加上在适当时间提出和回答这些问题的能力和意愿</p>\n<p>3.批判性的提问是检索信息和搜寻答案的最好方法</p>\n<p>4.弱势批判性思维是利用批判性思维来捍卫自己现有的立场和看法。强势批判性思维是利用批判性思维来评估所有断言和看法，尤其是自己的看法</p>\n<p>5.淘金式思维清单：</p>\n<p>&emsp;a.我有没有问“为什么” 别人要我相信他的观点</p>\n<p>&emsp;b.在我想到别人的说法可能有问题时有没有把它记下来</p>\n<p>&emsp;c.我对别人说过的话有没有进行客观评价</p>\n<p>&emsp;d.针对某一特定主题我有没有在别人合理说法的基础上形成自己的结论</p>\n<p>还有好多好多，看完了说再专门写一篇整理好的续，总理感觉我是海绵式思维和淘金式思维的集合体-_-#是不是有点自恋了？推荐大家看一下，真的是一本不错的书，不然也不会出到第10版。</p>\n<p>这个周末去看了一部电影《星际穿越》，唯一的遗憾是，看的是2d版，有机会再看一次3d max的。这部由《盗梦空间》，《蝙蝠侠前者》三部曲系列的导演克里斯托弗·诺兰执导的科幻和伦理大片，很科普也很烧脑袋。看完就是一个字：爽。吐血推荐各位去电影院看一下，然后知乎上有解答和评价。不能在这提问，有点剧透的嫌疑，还是到知乎提问吧。</p>\n<p>渐渐入冬，不知各位每天早上都几点起床，叫醒你们的是闹钟，还是梦想？今天看了一篇文章，<a href=\"http://www.ituring.com.cn/article/128044\" target=\"_blank\" rel=\"external\">《每天叫醒我的不是闹钟，而是梦想》</a>,其实真的蛮佩服的，最后这段话大家共勉：然而无论如何，请让梦想，而非闹钟叫醒你，因为今天总是你剩余生命里的第一天，从今日起拥有梦想，还不算晚。梦想还是要有的，万一实现了呢？—— by jack.ma</p>\n","source":"_posts/asking-the-right-questions.md","raw":"title: 学会提问\ndate: 2014-11-16 21:44:23\ntags:\n- 生活\ncategories: \n- 读书\n\n---\n又一年的双十一在这个星期的星期二，以571亿的交易额，妥妥的刷新着去年的数据。我想明年还会再刷新今年的数据，对我来说，唯一不同的是今年的这571亿，没有我的努力也没有我们家领导的努力。给小朋友买的披风还是11月12号买的。听到一个段子：只有长的丑的人才会安安心心的做一番事业，然后挣很多的钱，长的帅的，不是泡妞去了，就是被妞泡了。好多人估计都在想，终于找到自己穷的理由了？-_-#\n\n最近在读一本《学会提问》的书，也就是这篇文章的标题，虽然没有读完，但是我还是想摘抄一些东西：\n\n1.通往合理结论的道路往往从问题开始，并且一路都有问题相伴\n\n2.批判性思维有一套相互联系、环环相扣的关键问题的意识，同时加上在适当时间提出和回答这些问题的能力和意愿\n\n3.批判性的提问是检索信息和搜寻答案的最好方法\n\n4.弱势批判性思维是利用批判性思维来捍卫自己现有的立场和看法。强势批判性思维是利用批判性思维来评估所有断言和看法，尤其是自己的看法\n\n5.淘金式思维清单：\n\n&emsp;a.我有没有问“为什么” 别人要我相信他的观点\n  \n&emsp;b.在我想到别人的说法可能有问题时有没有把它记下来\n  \n&emsp;c.我对别人说过的话有没有进行客观评价\n  \n&emsp;d.针对某一特定主题我有没有在别人合理说法的基础上形成自己的结论\n\n还有好多好多，看完了说再专门写一篇整理好的续，总理感觉我是海绵式思维和淘金式思维的集合体-_-#是不是有点自恋了？推荐大家看一下，真的是一本不错的书，不然也不会出到第10版。\n\n这个周末去看了一部电影《星际穿越》，唯一的遗憾是，看的是2d版，有机会再看一次3d max的。这部由《盗梦空间》，《蝙蝠侠前者》三部曲系列的导演克里斯托弗·诺兰执导的科幻和伦理大片，很科普也很烧脑袋。看完就是一个字：爽。吐血推荐各位去电影院看一下，然后知乎上有解答和评价。不能在这提问，有点剧透的嫌疑，还是到知乎提问吧。\n\n渐渐入冬，不知各位每天早上都几点起床，叫醒你们的是闹钟，还是梦想？今天看了一篇文章，[《每天叫醒我的不是闹钟，而是梦想》](http://www.ituring.com.cn/article/128044),其实真的蛮佩服的，最后这段话大家共勉：然而无论如何，请让梦想，而非闹钟叫醒你，因为今天总是你剩余生命里的第一天，从今日起拥有梦想，还不算晚。梦想还是要有的，万一实现了呢？—— by jack.ma\n\n\n\n\n\n\n\n","slug":"asking-the-right-questions","updated":1416149486000,"excerpt":"","_id":"d6lxxqks88yzo4xm","comments":true,"layout":"post","photos":[],"link":""}],"Tag":[{"name":"生活","_id":"2krmfb4w4f626chk","posts":["gyp2np96yk44xr49","6pkm2cc9kxp045bo","y5o153pnrz1nos6r","bhtgw1mzp3n1vmdk","z7qlgu39hxpntm3n","1ol6ccyqwa6d1xz1","uppvcja1j75dsczo","poch1sca6urhlcgz","4i9vnynit18v3nzm","vhh0v15cgu3bltjs","d6lxxqks88yzo4xm"]},{"name":"编程","_id":"twq4t4wsw1wesux9","posts":["fqoyoqempc099ak9","mn2c3ye0mz938ns7","9f4yjutby56sdhny","vnvf5fguzcik5uqg"]},{"name":"浏览器","_id":"vg603wvepkmtjf8f","posts":["1neauukj3eyz29rm"]}]}